<!doctype html>
<html lang="en">

<!--
  @author Emerson Rocha <rocha(at)ieee.org>
  @license AGPL
  @version 0.6.0b2
-->

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Spatial Data Maching with OSM Schema</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css"
    integrity="sha384-5kMSQJ6S4Qj5i09mtMNrWpSi8iXw230pKU76xTmrpezGnNJQzj0NzXjQLLg+jE7k" crossorigin="anonymous">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"
    integrity="sha512-CSBhVREyzHAjAFfBlIBakjoRUKp5h7VSweP0InR/pAJyptH7peuhCsqAI/snV+TwZmXZqoUklpXp6R6wMnYf5Q=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <style>
    .leaflet-container {
      height: 800px;
      /* width: 600px; */
      width: 100%;
      max-width: 100%;
      max-height: 100%;
    }

    /** https://unpkg.com/browse/leaflet.markercluster@1.4.1/dist/ **/
    .leaflet-cluster-anim .leaflet-marker-icon,
    .leaflet-cluster-anim .leaflet-marker-shadow {
      -webkit-transition: -webkit-transform 0.3s ease-out, opacity 0.3s ease-in;
      -moz-transition: -moz-transform 0.3s ease-out, opacity 0.3s ease-in;
      -o-transition: -o-transform 0.3s ease-out, opacity 0.3s ease-in;
      transition: transform 0.3s ease-out, opacity 0.3s ease-in;
    }

    .leaflet-cluster-spider-leg {
      /* stroke-dashoffset (duration and function) should match with leaflet-marker-icon transform in order to track it exactly */
      -webkit-transition: -webkit-stroke-dashoffset 0.3s ease-out, -webkit-stroke-opacity 0.3s ease-in;
      -moz-transition: -moz-stroke-dashoffset 0.3s ease-out, -moz-stroke-opacity 0.3s ease-in;
      -o-transition: -o-stroke-dashoffset 0.3s ease-out, -o-stroke-opacity 0.3s ease-in;
      transition: stroke-dashoffset 0.3s ease-out, stroke-opacity 0.3s ease-in;
    }

    .leaflet-marker-pane img.pin-focus {
      /* filter: hue-rotate(120deg); */
      box-shadow: 0px 0px 3px 5px #eeea02;
    }

    .resize {
      resize: both;
      overflow: auto;
    }
  </style>
</head>

<body>
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark v_meta-element">
    <div class="container">
      <a class="navbar-brand" href="#">SDM <sup>v0.6.0b2</sup></a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
    </div>
  </nav>

  <div class="container my-1">
    <h1 class="v_meta-element">Spatial Data Maching <sup>with OSM Schema</sup></h1>
    <div class="col-lg-12 px-0">

      <ul class="nav nav-tabs v_filter_up-element" id="myTab" role="tablist">
        <li class="nav-item" role="presentation">
          <button class="nav-link active" id="home-tab" data-bs-toggle="tab" data-bs-target="#home-tab-pane"
            type="button" role="tab" aria-controls="home-tab-pane" aria-selected="true"><abbr
              title="Carrege arquivos externos para memória RAM do navegador. Permite filtrar campos e quais linhas de dados">Data
              import</abbr>
            <span class="badge text-bg-secondary">
              <span id="data_ex_count_i">0</span>
              / <span id="data_ex_count_t">0</span>
            </span>
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="profile-tab" data-bs-toggle="tab" data-bs-target="#profile-tab-pane"
            type="button" role="tab" aria-controls="profile-tab-pane" aria-selected="false"><abbr
              title="Para fatos (elementos, 'PoIs', ...) já carregados em memória, filtre o que deseja">Real time
              filter</abbr>
            <span class="badge text-bg-secondary"><span id="data_active_count">0</span></span></button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="export-tab" data-bs-toggle="tab" data-bs-target="#export-tab-pane" type="button"
            role="tab" aria-controls="export-tab-pane" aria-selected="false">Export</button>
        </li>
      </ul>

      <div class="tab-content v_filter_up-element" id="myTabContent">
        <div class="tab-pane fade show active" id="home-tab-pane" role="tabpanel" aria-labelledby="home-tab"
          tabindex="0">
          <form>
            <div class="row">
              <div class="col">
                <label for="external-data-file" class="form-label visually-hidden">Load external files</label>
                <input class="form-control form-control-lg" id="external-data-file" type="file"
                  onchange="Loader.readFilesOrParameters(this)"
                  accept=".json, .geojson, .geojsonl, .csv, .tsv, .yaml, .yml" multiple>

                <!-- <label for="fileNum">Arquivos:</label> -->
                Files:
                <output id="fileNum">0</output>;
                <!-- <label for="fileSize">Tamanho original:</label> -->
                Original Size:
                <output id="fileSize">0</output>
              </div>
            </div>
            <!-- <hr class=""> -->
            <div class="row">
              <h3 class="h4">Attributes to import for every item</h3>
              <div class="col">
                <label for="data_ex_fields_exporter">Keys/columns</label>
                <button type="button" class="" data-bs-toggle="tooltip" data-bs-placement="top"
                  data-bs-title="Regex-enabled case-sensitive list of field keys to, if exist in source data, be imported. (this means properties not listed here will NOT be loaded into the memory). Tip: you can use '.+' to allow anything">
                  🛈
                </button>
                <textarea class="form-control" data-conf="import_keys.global" placeholder=""
                  id="data_ex_fields_exporter" style="height: 200px">// Most frequent at the top (from HTML)
addr:.*
nohousenumber
name
source
// Incompleted Map features https://wiki.osm.org/wiki/Map_features
aerialway
amenity
barrier
boundary
building
building:.+
craft
emergency
geological
healthcare
highway
cycleway
busway
parking
parking:.+
historic
leisure
landuse
leisure
man_made
military
natural
office
place
power
line
public_transport
railway
bridge
tunnel
route
shop
sport
telecom
tourism
water
// (...)
// Subtags of https://wiki.osm.org/wiki/Map_features
police
government
service
// Contact-like data, (good for detect matches)
contact:.+
phone
email
// Reference-like and external identifiers (good for detect matches)
ref
ref:.+
wikidata
wikipedia
// Other metadata
source
source:.+
operator
population
embankment
fixme
note
website
url
opening_hours
ISO3166.*
currency
// Typical OSM Names wiki.osm.org/wiki/Names
name
name:.+
alt_name
alt_name:.+
int_name
int_name:.+
log_name
loc_name:.+
nat_name
nat_name.+
official_name
official_name:.+
old_name
old_name:.+
ref_name
ref_name:.+
reg_name
reg_name:.+
short_name
short_name:.+
// Allow HXL Standard hashtags
#.*
// Allow P{numeric} and Q{numeric} as shortcut for Wikidata
// P\d+
// Q\d+
// Other
@id</textarea>
                <div class="form-check">
                  <input class="form-check-input" type="checkbox" value="1" id="import_fields_anyifosm_nwr" checked>
                  <label class="form-check-label" for="import_fields_anyifosm_nwr">
                    (OSM export) Allow any field name if @id= starts with node/, way/ relation/ or note/
                  </label>
                </div>


              </div>
              <div class="col">
                <!-- future -->
                <label for="impor_aliases">Aliases (not implemented yet)</label>
                <button type="button" class="" data-bs-toggle="tooltip" data-bs-placement="top"
                  data-bs-title="Renamer for very common column names. Syntax: original_field|osm-schema-field|optional_function()">
                  🛈
                </button>
                <textarea class="form-control" data-conf="import_aliases.global" placeholder="" id="import_aliases"
                  style="height: 200px" disabled>//Wikidata related (from HTML)
itemLabel|name
item|wikidata|helper_wikidata_q()
loc|coordinate_location|helper_point()
geo|coordinate_location|helper_point()
                </textarea>
              </div>
            </div>
            <div class="row">
              <h3 class="h4">Selection of items to import</h3>
              <div class="col">
                <div class="mb-3">
                  <label for="data_ex_filter">Filter for hardcoded key=value</label>
                  <button type="button" class="" data-bs-toggle="tooltip" data-bs-placement="top"
                    data-bs-title="Fixed list which every imported item must match">
                    🛈
                  </button>
                  <textarea class="form-control" placeholder="key=value
addr:postcode=1234.?" data-conf="import_filter" id="data_ex_filter" style="height: 100px"></textarea>
                </div>
                <div class="mb-3">
                  <label for="match_strategy">Match Strategy</label>
                  <textarea class="form-control" placeholder="" data-conf="match_strategy" id="match_strategy"
                    style="height: 300px" disabled></textarea>
                </div>
              </div>
              <div class="col">
                <h4 class="h5">Use itens from a file to select items from import dataset</h4>
                <div class="mb-3">
                  <label for="import_reffile" class="form-label">Reference files</label>
                  <button type="button" class="" data-bs-toggle="tooltip" data-bs-placement="top"
                    data-bs-title="Select one or more files where the items of imported files must match to at least one item of these reference files">
                    🛈
                  </button>
                  <input class="form-control" type="file" id="import_reffile" onchange="Loader.readFileReference(this)"
                    accept=".json, .geojson" multiple>
                </div>
                <div class="input-group mb-3">
                  <span class="input-group-text" id="import_reffile_dist-label">Maximum distance (meters)</span>
                  <input type="text" class="form-control" placeholder="500" aria-label="Distance (m)"
                    aria-describedby="import_reffile_dist-label" id="import_reffile_dist" value="1000">
                </div>
                <div class="input-group mb-3">
                  <span class="input-group-text" id="import_reffile_dist2-label">Striter max. distance (meters)</span>
                  <input type="text" class="form-control" placeholder="500" aria-label="Distance (m)"
                    aria-describedby="import_reffile_dist2-label" id="import_reffile_dist2" value="100">
                </div>
                <div class="input-group">
                  <span class="input-group-text">Attributes to match</span>
                  <textarea class="form-control" aria-label="Attributes to match"
                    id="import_reffile_rules">addr:housenumber</textarea>
                  <!--
addr:housenumber
email
phone
-->
                </div>
                <div class="form-check">
                  <input class="form-check-input" type="checkbox" value="1" id="import_reffile_rules_missing" checked>
                  <label class="form-check-label" for="import_reffile_rules_missing">
                    Ignore if reference don't have
                  </label>
                </div>

                <div class="mb-3">
                  <label for="import_reffile_output" class="form-label">Result log of maching by reference</label>
                  <textarea class="form-control" id="import_reffile_output" rows="4" disabled></textarea>
                </div>
              </div>
            </div>
          </form>
        </div>
        <div class="tab-pane fade" id="profile-tab-pane" role="tabpanel" aria-labelledby="profile-tab" tabindex="0">
          <!-- <div class="alert alert-info alert-dismissible fade show" role="alert">
          Filtros ativos.
          <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
        </div> -->

          <div class="row">
            <!-- <label for="filter_active_simple" class="col-sm-2 col-form-label col-form-label-lg">Busca simples</label>
          <div class="col-sm-10">
            <input type="text" class="form-control form-control-lg" id="filter_active_simple"
              placeholder="Busca simples 1">
            <input type="text" class="form-control form-control-lg" id="filter_active_simple"
              placeholder="Busca simples 1">
          </div> -->

            <div class="input-group">
              <span class="input-group-text">Query filter</span>
              <textarea class="form-control" aria-label="With textarea" rows="3" id="filter_active_simple"></textarea>
            </div>
            <div class="input-group" id="extra_filter">
              <span class="input-group-text">Position</span>
              <textarea class="form-control" aria-label="Latitude, Longitude" rows="1" id="filter_active_latlon"
                placeholder="-12.34,56.78 (latitude, longitude), @fid= or URL"></textarea>
              <span class="input-group-text">Distance (m)</span>
              <input type="text" class="form-control" id="filter_active_latlon_dist" aria-label="distance" value="100">
            </div>
          </div>
          <!-- <form class="row gx-3 gy-2 align-items-center"> -->
          <form class="row g-3">
            <!--
            <div class="col-auto">
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="ui_filter_extras" checked>
                <label class="form-check-label" for="ui_filter_extras">
                  Extras
                </label>
              </div>
            </div>
            -->
            <div class="col-auto">
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="ui_text_preview" checked>
                <label class="form-check-label" for="ui_text_preview">
                  Text preview (with position)
                </label>
              </div>
            </div>
            <div class="col-auto">
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="ui_text_nopos_preview" checked>
                <label class="form-check-label" for="ui_text_nopos_preview">
                  Text preview (unknow position)
                </label>
              </div>
            </div>
            <div class="col-auto">
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="ui_map_preview" checked>
                <label class="form-check-label" for="ui_map_preview">
                  Map mode preview
                </label>
              </div>
            </div>
          </form>
        </div>
        <div class="tab-pane fade" id="export-tab-pane" role="tabpanel" aria-labelledby="export-tab" tabindex="0">
          <div class="row" style="margin-bottom: 1em">
            <div class="col">
              <h2>Export</h2>
              <div class="row">
                <div class="col">
                  <h3>Dataset</h3>
                  <h3>File format, content, and parts</h3>
                  <div class=" mb-3">
                    <label for="export_filename" class="form-label">Filename</label>
                    <div class="input-group">
                      <input type="text" class="form-control" id="export_filename" placeholder="" value="sdm-export">
                      <span class="input-group-text" id="export_fileext">.geojson</span>
                    </div>
                  </div>
                  <div class="form-check">
                    <input class="form-check-input" type="radio" name="export_filetype" id="export_filetype_a"
                      value=".geojson" checked>
                    <label class="form-check-label" for="export_filetype_a">
                      GeoJSON
                    </label>
                  </div>
                  <div class="form-check">
                    <input class="form-check-input" type="radio" name="export_filetype" id="export_filetype_b"
                      value=".geojsonl">
                    <label class="form-check-label" for="export_filetype_b">
                      GeoJSON Text Sequences ("GeoJSON Lines")
                    </label>
                  </div>
                  <div class="form-check">
                    <input class="form-check-input" type="radio" name="export_filetype" id="export_filetype_csv"
                      value=".csv" disabled>
                    <label class="form-check-label" for="export_filetype_csv">
                      CSV (Comma-separated Values)
                    </label>
                  </div>
                  <div class="form-check">
                    <input class="form-check-input" type="radio" name="export_filetype" id="export_filetype_tsv"
                      value=".tsv" disabled>
                    <label class="form-check-label" for="export_filetype_tsv">
                      TSV (Tab-separated Values)
                    </label>
                  </div>
                </div>
                <div class="col">
                  <h3>Content to export</h3>
                  <div class="form-check">
                    <input class="form-check-input" type="radio" name="export_content" id="export_content_a" value="1"
                      checked>
                    <label class="form-check-label" for="export_content_a">
                      Data imported (with pre-filtering only), data with spatial position
                    </label>
                  </div>
                  <div class="form-check">
                    <input class="form-check-input" type="radio" name="export_content" id="export_content_b" value="2"
                      disabled>
                    <label class="form-check-label" for="export_content_b">
                      Data imported (with pre-filtering only), data without spatial position
                    </label>
                  </div>
                  <div class="form-check">
                    <input class="form-check-input" type="radio" name="export_content" id="export_content_c" value="3"
                      disabled>
                    <label class="form-check-label" for="export_content_c">
                      Data from real-time filtering, data with spatial position
                    </label>
                  </div>
                  <div class="form-check">
                    <input class="form-check-input" type="radio" name="export_content" id="export_content_d" value="4"
                      disabled>
                    <label class="form-check-label" for="export_content_d">
                      Data from real-time filtering, data without spatial position
                    </label>
                  </div>
                  <h3>Number of parts</h3>
                  <p>(Not implemented yet. In theory saving as multiple files in theory would allow export large files)
                  </p>
                </div>
              </div>
              <div class="row text-center">
                <div class="col">
                  <button type="button" class="btn btn-primary mb-3 btn-lg text-center" id="export_download">Download
                    exported
                    file(s)</button>
                </div>
              </div>

            </div>
          </div>
          <!--
          <div class="row text-center" style="margin-bottom: 1em">
            <div class="col">
              <h3>Real time filter export</h3>
              <button type="button" class="btn btn-secondary" id="memory_download">Download GeoJSON memória</button>
            </div>
            <div class="col">
              <h3>Working memory export</h3>
              <button type="button" class="btn btn-secondary mb-3 text-center" id="active_download">Download
                GeoJSON</button>
            </div>
          </div>
          -->
        </div>
      </div>
    </div>
  </div>
  <!-- <div class="container my-5"> -->
  <div class="container-fluid">
    <div class="row">
      <!-- <div class="col-xl-4" id="output_items_spatial"> -->
      <div class="col-xl-4 col-lg-6" id="output_items_spatial">
        <textarea class="form-control" spellcheck="false" placeholder="Output..." id="output"
          style="height: 800px"></textarea>
      </div>

      <div class="col-xl-4 col-lg-6" id="output_items_nonspatial">
        <textarea class="form-control" spellcheck="false" placeholder="Output for items without position..."
          id="output2" style="height: 800px"></textarea>
      </div>

      <div id="map-container" class="col-xl-4" style="resize:vertical; overflow:auto;">
        <!-- <div id="map-container" class="col-xl-8" style="resize:vertical; overflow:auto;"> -->
        <div id='map'></div>
      </div>
    </div>
  </div>
  <div class="container">
    <div id="map_dataset_list_container" class="row">
      <div id='map_dataset_list'></div>
    </div>
  </div>

  <div class="container v_meta-element">
    <footer class="d-flex flex-wrap justify-content-between align-items-center py-3 my-4 border-top">
      <div class="col-md-4 d-flex align-items-center">
        <a href="/" class="mb-3 me-2 mb-md-0 text-muted text-decoration-none lh-1">
          <svg class="bi" width="30" height="24">
            <use xlink:href="#bootstrap" />
          </svg>
        </a>
        <span class="mb-3 mb-md-0 text-muted">Made in 🇧🇷 by <a
            href="https://www.openstreetmap.org/user/fititnt">Emerson Rocha</a>. License: <a
            href="https://www.gnu.org/licenses/agpl-3.0.en.html">AGPL</a>.


        </span>


      </div>
      <div class="col-md-4 d-flex">
        <span class="text-end"><a data-bs-toggle="modal" data-bs-target="#exampleModal" href="#">Help</a></span>
      </div>

      <!-- <ul class="nav col-md-4 justify-content-end list-unstyled d-flex">
        <li class="ms-3"><a class="text-muted" href="#"><svg class="bi" width="24" height="24">
              <use xlink:href="#twitter" />
            </svg></a></li>
        <li class="ms-3"><a class="text-muted" href="#"><svg class="bi" width="24" height="24">
              <use xlink:href="#instagram" />
            </svg></a></li>
        <li class="ms-3"><a class="text-muted" href="#"><svg class="bi" width="24" height="24">
              <use xlink:href="#facebook" />
            </svg></a></li>
      </ul> -->
    </footer>
  </div>

  <!-- Modal -->
  <div class="modal fade" id="exampleModal" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <h1 class="modal-title fs-5" id="exampleModalLabel">Ajuda</h1>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <h2>Aba importar</h2>
          <p>
            As opções aqui restringem quais elementos ficarão ativos para filtros posteriores de modo a permitir
            trabalhar até mesmo com arquivos enormes.
          <details>
            <summary>Opções</summary>
            <strong>Chaves</strong>: quais attributos devem ser carregados dos arquivos? Use * para qualquer
            attributo.<br>
            <strong>Filtro de chave-valor</strong>: um ou mais parametros por linha para ignorar o que carregar para
            memória.<br>
          </details>
          <h2>Aba filtro</h2>
          <p>
            Tela principal. Copie atributos de um exemplo semelhante já carregado no passo anterior e o resultado será
            filtrado em tempo real.
          </p>
          <h2>Aba exportar</h2>
          <p>
            <em>Não implementado.</em> Dica:
            Use a tela anterior para achar os objetos que tem interesse e copie e cole para seu editor OpenStreetMap
            favorito. Testado com iD
          </p>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Fechar</button>
          <!-- <button type="button" class="btn btn-primary">Save changes</button> -->
        </div>
      </div>
    </div>
  </div>
  <div class="modal fade" id="exampleModal2" tabindex="-1" aria-labelledby="exampleModal2Label" aria-hidden="true">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <h1 class="modal-title fs-5" id="exampleModal2Label">Opções</h1>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <textarea class="form-control" id="config"></textarea>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Fechar</button>
          <!-- <button type="button" class="btn btn-primary">Save changes</button> -->
        </div>
      </div>
    </div>
  </div>

  <!-- Critical error modal, start -->
  <div class="modal fade" id="criticalErrorModal" tabindex="-1" aria-labelledby="criticalErrorModalLabel"
    aria-hidden="true">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <h1 class="modal-title fs-5" id="criticalErrorModalLabel">Critical Error</h1>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body" id="critical_error_desc">
          ...(critical error message)...
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
          <!-- <button type="button" class="btn btn-primary">Save changes</button> -->
        </div>
      </div>
    </div>
  </div>
  <!-- Critical error modal, end -->
  <!--
  @TODO maybe implement off-canvas https://getbootstrap.com/docs/5.3/components/offcanvas/#methods
  -->
  <div style="position: fixed;  bottom: 0; padding: 5px; width: 100%;">
    V:
    <input type="checkbox" value="" id="v_meta" onchange="UI.ui_clean(event)" checked>
    <input type="checkbox" value="" id="v_filter_up" onchange="UI.ui_clean(event)" checked>
    <input type="checkbox" value="" id="v_filter_bottom" onchange="UI.ui_clean(event)" checked>
    |
    <input type="checkbox" value="" id="v_map_autofocus" onchange="UI.ui_clean(event)" checked
      title="enable/disable map autofocus when filters change">
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4"
    crossorigin="anonymous"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"
    integrity="sha384-RLIyj5q1b5XJTn0tqUhucRZe40nFTocRP91R/NkRJHwAe4XxnTV77FXy/vGLiec2"
    crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"
    integrity="sha512-dfX5uYVXzyU8+KHqj8bjo7UkOdg18PaOtpa48djpNbZHwExddghZ+ZmzWT06R5v6NSk3ZUfsH6FNEDepLx9hPQ=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <script>

    /**
     * From the initial author (Emerson Rocha) as 2024-06-16 v0.5.2-beta
     * to other programmers reading this code:
     *
     * 1. Yes, it is a big, single HTML page including the JS logic not
     *    already in external libraries
     * 2. Yes, it could get a rewrite. At the moment I'm unsure if this
     *    will get significant number of users to worth to me
     *    take more time doing the tool than actually using it
     * 3. Even at this current state, we could make it viable to
     *    at least small parts (e.g. addr:street complex parsing)
     *    allow others suggest small parts (function or maybe JS Classes)
     *    to make it "just work" for
     **/


    /**
     * @summary   Holds reference to imported data (including sliced versions and some statistics)
     **/
    let SDMData = {
      Auxiliary: [], // The extra working data after the import (no spatial position, e.g. CSV imports)
      AuxiliaryPreview: [], // SDM.Auxiliary sliced for preview on interface
      Main: [], // The full working data after the import (only part with geospatial position)
      MainPreview: [], // SDMData.Main sliced for preview on map
      Reference: [], // Data used only at import to pre-select uploads on SDMData.Main / SDMData.Auxiliary
      ReferenceStats: {
        "ref_files": 0,
        "ref_items": 0,
        "ref_items_no_pos": 0,
        "ref_items_no_tags": [],
        "target_files": 0,
        "target_items": 0,
        "target_items_no_pos": 0,
        "target_items_no_tags": 0,
      },
      _SourceFilesAll: new Set(),
      _SourceFilesStarted: new Set(),
      _SourceFilesFinished: new Set()
    }

    /**
     * @summary   Configurations. Interface may change it
     **/
    let SDMConf = {
      _: null, // instance of Configuration
      // _: new Configuration(), // instance of Configuration
      Preview: {
        text: 10000,  // maximum_active_display
        map: 10000  // maximum_active_display_map
      },
      Reference: {
        "distance": 1000,
        "distance2": 100,
        "rules": [],
        "allow_missing_ref": true
      },
      FromURIParameters: {},
      FromConfFileRAW: {},
      ImportAliasGlobal: [], // Conf: import_aliases.[type=global]
      ImportFilterGlobal: [], // Conf: import_filter
      ImportMatchStrategy: [], // Conf: match_strategy
      ImportKeysGlobal: [], // Conf: import_keys.[type=global]
      conf_init_file: "./init.sdm.yml",
      conf_init_extras: [
        "./example/hxlstandard-to-osm.sdm.yml",
        "./example/wikidata-to-osm.sdm.yml",
      ]
    }

    let SDMOption = {

      // Text fields to attempt automatic detection
      AutoField: {
        // x,y may not means this
        // @see https://gis.stackexchange.com/questions/11626/does-y-mean-latitude-and-x-mean-longitude-in-every-gis-software
        pos: {
          latitude: [
            "@latitude",
            "latitude",
            "Latitude",
            "LATITUDE",
            "@lat",
            "@y",
            "Y",
            "y",
            "#geo +lat",
            "#geo+lat"
          ],
          longitude: [
            "@longitude",
            "longitude",
            "Longitude",
            "LONGITUDE",
            "@lon",
            "@x",
            "X",
            "x",
            "#geo +lon",
            "#geo+lon"
          ],
          mixed_point: [
            "coordinate_location",
            "geometry",
          ]
        }
      },

      // Not fully implemented
      Renamer: {
        // Typical, Wikidata
        "itemLabel": ["name"],
        "item": ["wikidata", "helper_wikidata_q()"],
        "loc": ["coordinate_location", "helper_point()"],
        "geo": ["coordinate_location", "geo()"],

        // Wikidata, alias for some place identifiers, using the P themselves
        // as part of some alternatives bellow
        // Typical, HXL Standard + Ps of Wikidata
        "#country+code+num+v_m49": ["ISO3166-1:numeric"],
        "#country +code +num +v_m49": ["ISO3166-1:numeric"],
        "P299": ["ISO3166-1:numeric"],
        // "ISO3166-1:numeric": ["#country+code+num+v_m49", "#country +code +num +v_m49", "P299"],
        "#country+code+v_iso2": ["ISO3166-1:alpha2"],
        "#country +code +v_iso2": ["ISO3166-1:alpha2"],
        "P297": ["ISO3166-1:alpha2"],
        // "ISO3166-1:alpha2": ["#country+code+v_iso2", "#country +code +v_iso2", "P297"],
        "#country+code+v_iso3": ["ISO3166-1:alpha3"],
        "#country +code +v_iso3": ["ISO3166-1:alpha3"],
        "P298": ["ISO3166-1:alpha3"],
        // "ISO3166-1:alpha3": ["#country+code+v_iso3", "#country +code +v_iso3", "P298"],
        "#date+start": ["start_date"],
        "#currency+code": ["currency"],
        "#currency +code": ["currency"],
        // "currency": ["#currency+code", "#currency +code"],
        "#country+name+preferred": ["int_name"],
        "#country +name +preferred": ["int_name"],
        // "int_name": ["#country+name+preferred", "#country +name +preferred"],
      }
    }

    // Path to internal YAML configutation file to always load at start
    //const conf_init_file = "./init.sdm.yml"
    // const conf_init_extras = [
    //   "./example/hxlstandard-to-osm.sdm.yml",
    //   "./example/wikidata-to-osm.sdm.yml",
    // ]

    // const maximum_active_display = 10000
    // const maximum_active_display_map = 10000
    // var WorkingData = []
    // var SDMData.MainPreview = []

    // @TODO maybe allow multiple tabular data
    // var TabularData = []
    // var TabularDataPreview = []

    // let ReferenceData = []

    // let reffile_options = {
    //   "distance": 1000,
    //   "distance2": 100,
    //   "rules": [],
    //   "allow_missing_ref": true
    // }

    // let ReferenceDataMatchStatistics = {
    //   "ref_files": 0,
    //   "ref_items": 0,
    //   "ref_items_no_pos": 0,
    //   "ref_items_no_tags": [],
    //   "target_files": 0,
    //   "target_items": 0,
    //   "target_items_no_pos": 0,
    //   "target_items_no_tags": 0,
    // }

    // // x,y may not means this
    // // @see https://gis.stackexchange.com/questions/11626/does-y-mean-latitude-and-x-mean-longitude-in-every-gis-software
    // const fields_latitude = [
    //   "latitude",
    //   "Latitude",
    //   "LATITUDE",
    //   "@latitude",
    //   "@lat",
    //   "Y",
    //   "y",
    //   "@y"
    // ]

    // const fields_longitude = [
    //   "longitude",
    //   "Longitude",
    //   "LONGITUDE",
    //   "@longitude",
    //   "@lon",
    //   "X",
    //   "x",
    //   "@x"
    // ]

    // @TODO reduce the number of globals here
    let _Etc = {
      WorkingInputFiles: [],
      refpoint_latlon: null,
      refpoint_distance: 10,
      enabled_files: [-1],
      hide_did: -1,
      hide_did_dist: 25,
      hide_did_keys: [],
      hide_did_affected: [],
      focus_did: -1,
      // import_fields_anyifosm_nwr: true,
      debounceTimerFilters: 0,
      debounceAttemptedCount: 0,
      debounceRealCount: 0,
      locale_number: 'pt',
      _is_exportable: [],
      _is_not_exportable: [],
      _readfile_start_time: -1
    }


    // Loading order = index do arquivo
    //var WorkingInputFiles = []
    // var refpoint_latlon = null // [-12.34, 56.78]
    // let refpoint_latlon = null // [-12.34, 56.78]
    //var refpoint_latlon2 = null // [-12.34, 56.78]
    // var refpoint_latitude = null
    // var refpoint_longitude = null
    // let refpoint_distance = 10
    // var WorkingDataFiltered = []

    // let filter_dids = []
    // let enabled_files = [-1]
    //let hide_did = -1
    // let hide_did_dist = 25
    // let hide_did_keys = []
    //let hide_did_affected = [] // Arrays of zeroes, one per item
    //let focus_did = -1
    // let import_fields_anyifosm_nwr = true

    // let debounceTimerFilters
    // let debounceAttemptedCount = 0
    // let debounceRealCount = 0

    // const maximum_active_display = 1000
    // const maximum_active_display = 25000
    // const maximum_active_display = 1000
    // const maximum_active_display_map = 1000
    // const maximum_active_display = 10000
    // const maximum_active_display_map = 10000
    //const locale_number = 'pt'
    // const data_active_count_m = document.getElementById("data_active_count_m");
    // let _is_exportable = []
    // let _is_not_exportable = []

    // let _readfile_start_time = -1
    //const start_time = new Date()

    // console.log('refpoint_latlon', refpoint_latlon)
    // UIb.
    const UIb = {
      output: document.getElementById("output"),
      output2: document.getElementById("output2"),
      filter_active_simple: document.getElementById("filter_active_simple"),
      data_ex_filter: document.getElementById("data_ex_filter"),
      data_ex_fields_exporter: document.getElementById("data_ex_fields_exporter"),
      data_ex_count_i: document.getElementById("data_ex_count_i"),
      data_ex_count_t: document.getElementById("data_ex_count_t"),
      data_active_count: document.getElementById("data_active_count"),
    }

    // const output = document.getElementById("output");
    // const output2 = document.getElementById("output2");
    // const filter_active_simple = document.getElementById("filter_active_simple");
    // const data_ex_filter = document.getElementById("data_ex_filter");
    // const data_ex_fields_exporter = document.getElementById("data_ex_fields_exporter");
    // const data_ex_count_i = document.getElementById("data_ex_count_i");
    // const data_ex_count_t = document.getElementById("data_ex_count_t");
    // const data_active_count = document.getElementById("data_active_count");
    // const render_active = document.getElementById("render_active");


    // /**
    //  * Fetch remote file. For use that mimic syncronous
    //  * fetch:
    //  * const mydata = await fetchRemoteFile('https://example.com/data.csv');
    //  **/
    // async function fetchRemoteFile(url) {
    //   // https://stackoverflow.com/questions/24586110
    //   // https://stackoverflow.com/questions/44735669/
    //   return fetch(url)
    //     // .then(response => response.json())
    //     .then(response => response.text())
    //     .catch((error) => {
    //       console.log(error);
    //     });
    // }

    class Configuration {
      name = 'sdm-project'
      conf_raw = {}
      // _promises_count = 0
      // _promises = new Set([]);
      _promises = new Set();
      _fileupload = new Set();
      constructor() {
        // this.name = name
        // this._init_object = init_object
      }

      set name(name) {
        this.name = name
      }

      add_data_file(url_or_fileupload, is_upload) {
        if (is_upload) {
          this._fileupload.add(url_or_fileupload)
        }
      }

      // set add_config(conf_object, uid = null) {
      add_config(conf_object, uid_promise = null) {
        if (!conf_object && uid_promise) {
          this._promises.add(uid_promise)
        } else {
          // const conf_object = Configuration.object_from_yaml(config)
          // this.conf_raw = { ...this.conf_raw, ...conf_object }

          this.conf_raw = Helper.mergeDeep(this.conf_raw, conf_object)
          // const temp = mergeDeep(this.conf_raw, conf_object)

          // this.conf_raw = temp
          if (uid_promise) {
            this._promises.delete(uid_promise)
          }
        }
      }

      add_config_remote(conf_remote_url, uid_promise = null) {

        console.log('Configuration.add_config_remote started', conf_remote_url, uid_promise)
        // const conf_object = Configuration.object_from_yaml(config)

        // @TODO implement sequential merge of the configutation.
        //       now it may load in not so predictable ways.

        // console.log('SDMConf._.add_config_remote', conf_remote_url)

        const that = this

        if (!conf_remote_url && uid_promise) {

          // This is just a hint for promisse we dont know content yet
          this._promises.add(uid_promise)
          return true
        }

        // this._promises.add(conf_remote_url)
        this._promises.add(uid_promise || conf_remote_url)

        let response_text = fetch(conf_remote_url)
          .then((response) => {
            if (!response.ok) {
              throw Error(response.statusText)
            }
            // return response
            return response.text()
          })
          // .then(function (response) {
          .then(function (response_text) {
            // const response_text = response.text()
            const conf_object = Configuration.object_from_yaml(response_text)
            // that.conf_raw = { ...that.conf_raw, ...conf_object }
            that.conf_raw = Helper.mergeDeep(that.conf_raw, conf_object)

            // that._promises.delete(conf_remote_url)
            that._promises.delete(uid_promise || conf_remote_url)
            // console.log('Configuration.add_config_remote finished', conf_remote_url)
            // console.log('..that.conf_raw2', that.conf_raw, response_text)

            //return response.text()
          })
          .catch((error) => {
            UI.reportErrorCritical("Configuration loading error", `[${conf_remote_url}] failed to load`)
            // console.log(error);
          });
      }

      get remote_data() {

        // console.log('...remote_data conf_raw', this.conf_raw)
        if (this.conf_raw && this.conf_raw.data && this.conf_raw.data.length > 0) {
          return this.conf_raw.data
        } else {
          return null
        }
      }

      ready(cb) {

        // console.log('Configuration().ready() called', cb, this._promises)

        const that = this
        if (that._promises.size === 0) {
          // console.log('Configuration().ready() already ready', that._promises)
          that.update_import_alias()
          that.update_import_filter()
          that.update_import_match_strategy()
          that.update_import_keys()
          cb()
        } else {
          const handle = setInterval(() => {
            if (that._promises.size === 0) {
              // console.log('Configuration().ready() now', that._promises)
              clearInterval(handle);
              that.update_import_alias()
              that.update_import_filter()
              that.update_import_match_strategy()
              that.update_import_keys()
              cb()
            } else {
              // console.log('Configuration().ready(), waiting...', that._promises)
            }
          }, 100);
        }
      }

      static object_from_yaml(yaml_text) {
        // return {"aaaa": 2222}
        // const yaml = require('js-yaml');
        try {
          const doc = jsyaml.load(yaml_text);
          return doc
        } catch (error) {
          console.error(error);
          return {}
        }
      }

      update_import_alias() {

        // console.log('update_import_alias run')
        const el = document.querySelectorAll("[data-conf='import_aliases.global']")[0]
        let alias_list = []
        let alias_list_clean = new Set()
        if (this.conf_raw && this.conf_raw.import_aliases && this.conf_raw.import_aliases.length > 0) {
          // console.log('... internal update_import_alias')
          for (let index = 0; index < this.conf_raw.import_aliases.length; index++) {
            const element = this.conf_raw.import_aliases[index]
            if (element.type && element.type === 'global') {
              element.aliases.forEach(alias_or_comment => {
                alias_list.push(alias_or_comment)
                if (!alias_or_comment.trim().startsWith("//")) {
                  let pairs = alias_or_comment.trim().split("|")
                  alias_list_clean.add(pairs)
                }
              })
            }
          }

          if (alias_list.length > 0) {
            el.value = alias_list.join("\n")
          }
          if (alias_list_clean.size > 0) {
            SDMConf.ImportAliasGlobal = alias_list_clean
          }
        }
      }

      update_import_filter() {

        // console.log('update_import_filter run')
        const el = document.querySelectorAll("[data-conf='import_filter']")[0]
        let filter_list = []
        let filter_list_clean = new Set()
        if (this.conf_raw && this.conf_raw.import_filter && this.conf_raw.import_filter.length > 0) {
          // console.log('... internal update_import_filter')
          for (let index = 0; index < this.conf_raw.import_filter.length; index++) {
            const element = this.conf_raw.import_filter[index]
            // console.log('el', element)
            filter_list.push(element)
            if (!element.trim().startsWith("//")) {
              let pairs = element.trim().split("=")
              filter_list_clean.add(pairs)
            }
          }

          if (filter_list.length > 0) {
            el.value = filter_list.join("\n")
          }
          if (filter_list_clean.size > 0) {
            SDMConf.ImportFilterGlobal = filter_list_clean
          }
        }
      }

      update_import_match_strategy() {

        // @TODO finish update_import_match_strategy()
        // console.log('update_import_match_strategy run')
        const el = document.querySelectorAll("[data-conf='match_strategy']")[0]
        let ms_list = []
        let ms_list_clean = new Set()
        if (this.conf_raw && this.conf_raw.match_strategy && this.conf_raw.match_strategy.length > 0) {
          // console.log('... internal update_import_match_strategy')
          for (let index = 0; index < this.conf_raw.match_strategy.length; index++) {
            const element = this.conf_raw.match_strategy[index]
            // console.log('el', element)
            ms_list_clean.add(element)

          }

          if (ms_list_clean.size > 0) {
            const yaml_text = jsyaml.dump(this.conf_raw.match_strategy)
            el.value = yaml_text
            SDMConf.ImportMatchStrategy = ms_list_clean
          }
        }
      }

      update_import_keys() {

        // console.log('update_import_keys run')
        const el = document.querySelectorAll("[data-conf='import_keys.global']")[0]
        let keys_list = []
        let keys_list_clean = new Set()
        if (this.conf_raw && this.conf_raw.import_keys && this.conf_raw.import_keys.length > 0) {
          // console.log('... internal update_import_keys')
          for (let index = 0; index < this.conf_raw.import_keys.length; index++) {
            const element = this.conf_raw.import_keys[index]
            if (element.type && element.type === 'global') {
              element.keys.forEach(key_or_comment => {
                keys_list.push(key_or_comment)
                if (!key_or_comment.trim().startsWith("//")) {
                  keys_list_clean.add(key_or_comment.trim())
                }
              })
            }
          }

          if (keys_list.length > 0) {
            el.value = keys_list.join("\n")
          }
          if (keys_list_clean.size > 0) {
            SDMConf.ImportKeysGlobal = keys_list_clean
          }
        }
      }
    }

    class Geo {


      /**
        * Calculates the haversine distance between point A, and B.
        * @author https://stackoverflow.com/a/48805273/894546
        *
        * @param {number[]} latlngA [lat, lng] point A
        * @param {number[]} latlngB [lat, lng] point B
        * @param {boolean} isMiles If we are using miles, else km.
        */
      static haversineDistance = ([lat1, lon1], [lat2, lon2], isMiles = false) => {
        const toRadian = angle => (Math.PI / 180) * angle;
        const distance = (a, b) => (Math.PI / 180) * (a - b);
        const RADIUS_OF_EARTH_IN_KM = 6371;

        const dLat = distance(lat2, lat1);
        const dLon = distance(lon2, lon1);

        lat1 = toRadian(lat1);
        lat2 = toRadian(lat2);

        // Haversine Formula
        const a =
          Math.pow(Math.sin(dLat / 2), 2) +
          Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
        const c = 2 * Math.asin(Math.sqrt(a));

        let finalDistance = RADIUS_OF_EARTH_IN_KM * c;

        if (isMiles) {
          finalDistance /= 1.60934;
        }

        return finalDistance;
      };

      static get_field_latnon_if_exist(field_names) {
        // let latitude = false
        // let longitude = false
        // let index_ = false

        // for (let index = 0; index < SDMOption.AutoField.pos.latitude.length; index++) {
        for (let index = 0; index < SDMOption.AutoField.pos.latitude.length; index++) {
          const _lat = SDMOption.AutoField.pos.latitude[index];
          const _lon = SDMOption.AutoField.pos.longitude[index];
          if (field_names.indexOf(_lat) > -1 && field_names.indexOf(_lon) > -1) {
            return [_lat, _lon]
          }
        }

        return false
      }

      static get_field_latnon_if_wkt_exist(item_properties) {
        // let latitude = false
        // let longitude = false
        // let index_ = false

        function _extract(value) {
          if (!!value && /^point|linestring|POLYGON.*/i.test(value)) {
            const value2 = value.replace(/[a-zA-Z]+/, "").trim()
            const value3 = value2.split(",")
            const value4 = value3[0].replace("(", "").replace(")", "")
            const value5 = value4.split(" ")
            if (value5.length === 2) {
              return value5
            }
          }
          return false
        }

        // @TODO implement other more complex cases
        //       https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry

        // for (let index = 0; index < SDMOption.AutoField.pos.latitude.length; index++) {
        for (let index = 0; index < SDMOption.AutoField.pos.mixed_point.length; index++) {
          let _key = SDMOption.AutoField.pos.mixed_point[index]

          if (_key in item_properties) {
            let _candidate = _extract(item_properties[_key])
            if (_candidate !== false) {
              return _candidate
            }
          }

          // // const _lat = SDMOption.AutoField.pos.latitude[index];
          // const _lon = SDMOption.AutoField.pos.longitude[index];
          // if (field_names.indexOf(_lat) > -1 && field_names.indexOf(_lon) > -1) {
          //   return [_lat, _lon]
          // }
        }

        return false
      }

      static get_field_wkt_if_exist(field_names) {
        // early attempt to see if could have WKT field
        for (let index = 0; index < SDMOption.AutoField.pos.mixed_point.length; index++) {
          let _key = SDMOption.AutoField.pos.mixed_point[index]
          if (_key in field_names) {
            return _key
          }
        }

        return false
      }

      /**
       * 
       **/
      static geojson_feature_centroid(feature) {

        // Sorry, that's what we got for now
        return Geo.geojson_feature_pseudo_centroid(feature)
      }

      /**
       *
       * Not recommended use geojson_feature_centroid()
       *
       * Temporary function to do quick return coordinates
       * of the first point instead of do the complex calculation
       * 
       **/
      static geojson_feature_pseudo_centroid(feature) {
        if (!feature || !("coordinates" in feature["geometry"])) {
          return null
        }
        let one_lat = false
        let one_lon = false

        // https://datatracker.ietf.org/doc/html/rfc7946
        let pos = feature["geometry"]["coordinates"]
        // console.log('pos', pos, Array.isArray(pos), Array.isArray(pos[0]), pos.length)
        if (Array.isArray(pos) && !Array.isArray(pos[0]) && pos.length >= 2) {
          one_lat = pos[0]
          one_lon = pos[1]
        } else if (Array.isArray(pos) && Array.isArray(pos[0]) && pos[0].length >= 2) {
          one_lat = pos[0][0]
          one_lon = pos[0][1]
        } else if (Array.isArray(pos) && Array.isArray(pos[0]) && Array.isArray(pos[0][0]) && pos[0][0].length >= 2) {
          one_lat = pos[0][0][0]
          one_lon = pos[0][0][1]
        }
        if (one_lat && one_lon) {
          return [one_lat, one_lon]
        }
        return null
      }

    }

    /**
     * Functions that do not fit other classes
     *
     **/
    class Helper {

      //let debounceTimer;
      static debounce = (callback, time) => {
        // window.clearTimeout(debounceTimer);
        window.clearTimeout(_Etc.debounceTimerFilters);
        // debounceTimer = window.setTimeout(callback, time);
        _Etc.debounceTimerFilters = window.setTimeout(callback, time);
      }

      /**
       * Calculate datetime difference betewn dates
       * Used for profile of loading very large files
       *
       * @author https://stackoverflow.com/a/59793084/894546
       **/
      static humanDiff(t1, t2) {
        const diff = Math.max(t1, t2) - Math.min(t1, t2)
        const SEC = 1000, MIN = 60 * SEC, HRS = 60 * MIN

        const hrs = Math.floor(diff / HRS)
        const min = Math.floor((diff % HRS) / MIN).toLocaleString('en-US', { minimumIntegerDigits: 2 })
        const sec = Math.floor((diff % MIN) / SEC).toLocaleString('en-US', { minimumIntegerDigits: 2 })
        const ms = Math.floor(diff % SEC).toLocaleString('en-US', { minimumIntegerDigits: 4, useGrouping: false })

        return `${hrs}:${min}:${sec}.${ms}`
      }

      /**
      * Performs a deep merge of objects and returns new object. Does not modify
      * objects (immutable) and merges arrays via concatenation.
      * 
      * @author https://stackoverflow.com/a/48218209/894546
      *
      * @param {...object} objects - Objects to merge
      * @returns {object} New object with merged key/values
      */
      static mergeDeep(...objects) {
        const isObject = obj => obj && typeof obj === 'object';

        return objects.reduce((prev, obj) => {
          Object.keys(obj).forEach(key => {
            const pVal = prev[key];
            const oVal = obj[key];

            if (Array.isArray(pVal) && Array.isArray(oVal)) {
              prev[key] = pVal.concat(...oVal);
            }
            else if (isObject(pVal) && isObject(oVal)) {
              prev[key] = Helper.mergeDeep(pVal, oVal);
            }
            else {
              prev[key] = oVal;
            }
          });

          return prev;
        }, {});
      }

    }

    class Loader {

      /**
       * readFile. Accept either the input element (the one user select files from disk)
       * or a list of remote files to load.
       * 
       * Ideally this should be refactored, but is working for now.
       * 
       **/
      static async readFile(input, remote_files) {
        // if (input.files.length > 1) {
        //   console.warn('No momento implementado apenas primiro arquivo. Ignorando demais')
        // }
        // let _data_ex_count_i = 0
        var _data_ex_count_i = 0
        // let _data_ex_count_t = 0
        var _data_ex_count_t = 0
        let filter_options = MatchPrompt.parse_options(UIb.data_ex_filter.value)
        let fields_to_export = MatchPrompt.parse_options_simple(UIb.data_ex_fields_exporter.value)
        const import_fields_anyifosm_nwr = document.getElementById("import_fields_anyifosm_nwr").checked
        var examples = []
        // let files_loaded = 0
        var files_loaded = 0
        let files_csv_total = 0
        let files_csv_finished = 0
        // let reader = null
        // input.files.forEach(function (file) {

        let stack_left = []
        // const start_time = new Date()
        _Etc._readfile_start_time = new Date()

        // Array.from(input.files).forEach(function (file) {
        //   stack_left.push(file)
        // })

        // Array.from(input.files).forEach(function (file) {
        function readFileMainLoop(file, remote_file) {

          _Etc.WorkingInputFiles.push(file || remote_file)

          //START
          async function processIndividualFile(
            file, remote_file, cb
          ) {

            let is_file_upload = true
            let data_file_uid = ""


            if (!file) {
              // merely to mimic file.name
              file = remote_file
            }

            if (!file.name.endsWith(".yml") && !file.name.endsWith(".yaml")) {
              // console.log(')))000000file', file)
              // console.log(')))000000file', typeof file)
              // if (file instanceof File) {
              // if (input && input.files) {
              // if (!file.name.startsWith("http")) {
              // if (!file.name.startsWith("http")) {
              if (!file.url) {
                data_file_uid = "file://" + file.name
              } else {
                data_file_uid = file.url
              }
              SDMData._SourceFilesStarted.add(data_file_uid)
            }

            if (file.name.endsWith(".yml") || file.name.endsWith(".yaml")) {
              // skip. already done earlier

            } else if (file.name.endsWith(".geojsonl")) {
              // console.log("Note: geojsonl still imperfect implementation")

              let _last_part = ''
              let _separator = null
              let _current_parts = []
              let _active_part = ''
              let _skipped_chunks_parts = 0

              let input_file_index = files_loaded + 1

              let profile_times = {

              }

              // @TODO this part of remote stream for geojsonl needs be tested
              // _streamfile = file || remote_file._response
              // _streamfile = file || fetch(remote_file)
              let _streamfile = file
              //let _download = null

              //console.log('..lk.', file, remote_file)

              if (remote_file && remote_file.url) {

                // @TODO implement loading .geojsonl from remote sources (fititnt - 2024-08-08 22:37 BRT)
                console.warn("IMPORTANT: reading .geojsonl not fully implemented for remote sources (uploading from local disk should still be working)")
                // @see https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Using_readable_streams
                // @see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
                _streamfile = remote_file._response
                _streamfile = fetch(remote_file.url).then(
                  response => { return response.body.getReader() }
                )
                //_streamfile = remote_file.response
                // _file = remote_file.url
                //_download = true
              }

              //file
              _streamfile
                .stream()
                .pipeThrough(new TextDecoderStream())
                .pipeTo(new WritableStream({
                  start(controller) {
                    profile_times[file.name] = new Date()
                    console.log(`WritableStream start: ${file.name}`)
                    // if (console.profile) {
                    //   console.profile(`WritableStream${file.name}`)
                    // }
                  },
                  write(textChunk) {
                    let _active_stack = []
                    let _geojson_string = ''
                    let _geojson_object = null
                    let match_score = -1

                    // RS + LF
                    // https://www.rfc-editor.org/rfc/rfc8142
                    if (textChunk.includes(String.fromCharCode(30, 10))) {
                      _current_parts = textChunk.split(String.fromCharCode(30, 10))
                    } else {
                      _current_parts = [textChunk]
                    }

                    _current_parts = _current_parts.filter(Boolean)

                    while (_current_parts.length != 0) {
                      if (_last_part != '') {
                        _active_part = _last_part + _current_parts.shift()
                        _last_part = []
                      } else {
                        _active_part = _last_part + _current_parts.shift().trim("\n")
                      }
                      _active_stack.push(_active_part)
                    }

                    while (_active_stack.length != 0) {
                      _geojson_string = _active_stack.shift()
                      _geojson_object = null
                      try {
                        _geojson_object = JSON.parse(_geojson_string);

                        // Try to clean last as soon as theres a clean match
                        _last_part = ''
                      } catch (e) {
                        // At end of chunk part is expected to sometimes have partial
                        if (_active_stack.length === 0) {
                          _active_part = _last_part + _geojson_string
                        } else {
                          _skipped_chunks_parts += 1
                          // console.error(`fileReader ${file} error in the middle of chunks`, e, _geojson_string)
                        }
                      }

                      if (_geojson_object !== null) {
                        _data_ex_count_t += 1

                        if (!(filter_options === null || Matcher.filter(_geojson_object, filter_options))) {
                          continue
                        }

                        if (SDMData.Reference.length !== 0) {
                          match_score = Matcher.filter_by_reference_on_import(_geojson_object, SDMConf.Reference)
                          // console.log('__match_score', match_score, item3, SDMConf.Reference)
                          if (match_score < 50) {
                            continue
                          }
                        }
                        _data_ex_count_i += 1
                        SDMData.Main.push(Matcher.select_attributes(_geojson_object, fields_to_export, input_file_index, _data_ex_count_i, import_fields_anyifosm_nwr))

                      }
                    }

                  },
                  close(controller) {
                    const t1 = profile_times[file.name]
                    const t2 = new Date()
                    const diff = Helper.humanDiff(t1, t2)
                    console.log(`WritableStream end: ${file.name} took: ${diff}`)
                    // if (console.profile) {
                    //   console.profileEnd(`WritableStream${file.name}`)
                    // }

                    return new Promise((resolve, reject) => {
                      cb(`Loaded ${file.name}`)
                      SDMData._SourceFilesFinished.add(data_file_uid)
                      resolve()
                    })
                  },
                  // }, queuingStrategy))
                }))

              // @TODO check if here will work the fileloaded
              // files_loaded += 1

            } else if (file.name.endsWith(".csv") || file.name.endsWith(".tsv")) {
              // console.log("@TODO", file)
              var input_file_index = files_loaded + 1

              let _papa_initialize = false
              let _papa_to_geojson = false
              let _papa_latlon = []
              let _papa_wkt = false
              let _papa_wkt_field = ''

              files_csv_total += 1

              let _file = file
              let _download = null
              if (remote_file && remote_file.url) {
                _file = remote_file.url
                _download = true
              }

              // console.log('########papaparse', _file, remote_file)

              // Papa.parse(bigFile, {
              // Papa.parse(file, {
              Papa.parse(_file, {
                worker: false,
                download: _download,
                header: true,
                step: function (row) {
                  // console.log("Row:", row.data);
                  _data_ex_count_i += 1

                  // tabular input more likely to need this
                  row.data = MatchPrompt._import_keys_renamer(row.data)
                  row.data = MatchPrompt._import_values_processor(row.data)

                  if (_papa_initialize === false) {
                    _papa_initialize = true
                    _papa_latlon = Geo.get_field_latnon_if_exist(Object.keys(row.data))
                    _papa_wkt = Geo.get_field_wkt_if_exist(row.data)
                    // console.log('---', _papa_latlon, _papa_wkt, Object.keys(row.data))
                    if (_papa_latlon !== false || _papa_wkt !== false) {
                      _papa_to_geojson = true
                    }
                  }

                  let _lat = 0.0
                  let _lon = 0.0
                  let _latlon = []
                  if (_papa_to_geojson) {
                    if (_papa_latlon !== false) {
                      _lat = parseFloat(row.data[_papa_latlon[0]])
                      _lon = parseFloat(row.data[_papa_latlon[1]])
                    } else {
                      _latlon = Geo.get_field_latnon_if_wkt_exist(row.data)
                      // console.log('..._latlon', _latlon, row.data)
                      if (_latlon !== false) {
                        // swaped?
                        _lat = parseFloat(_latlon[1])
                        _lon = parseFloat(_latlon[0])
                      }
                    }
                  }
                  if (isNaN(_lat) || isNaN(_lon)) {
                    _lat = 0.0
                    _lon = 0.0
                  }
                  // console.log( [_lon, _lat])

                  let active_item = Matcher.select_attributes({
                    // "geometry": {
                    "geometry": {
                      "type": "Point",
                      // "coordinates": [0.0, 0.0]
                      "coordinates": [_lon, _lat]
                    },
                    "properties": row.data,
                    "type": "Feature"
                  }, fields_to_export, input_file_index, _data_ex_count_i)

                  // console.log('Papa.parse start', active_item)

                  if (!(filter_options === null || Matcher.filter(active_item, filter_options))) {
                    return true
                  }

                  // console.log('Papa.parse end', active_item)

                  if (SDMData.Reference.length !== 0) {
                    match_score = Matcher.filter_by_reference_on_import(active_item, SDMConf.Reference)
                    // console.log('__match_score', match_score, item3, SDMConf.Reference)
                    if (match_score < 50) {
                      return true
                    }
                  }

                  // const _data_ex_count_t_local = _data_ex_count_t
                  if (_papa_to_geojson) {
                    SDMData.Main.push(active_item)
                  } else {
                    SDMData.Auxiliary.push(active_item)
                  }


                },
                complete: function () {
                  console.log("CSV import for file finished", file)
                  // SDMData.AuxiliaryPreview = SDMData.Auxiliary
                  files_csv_finished += 1
                  return new Promise((resolve, reject) => {
                    cb(`Loaded ${file.name}`)
                    SDMData._SourceFilesFinished.add(data_file_uid)
                    resolve()
                  })
                }
              });
            } else {

              var input_file_index = files_loaded + 1

              // Last part: generic json/geojson (either remote or local)

              // console.log('poin')

              function _parser_geojson_text(text) {
                let original_data = JSON.parse(text)

                for (let index = 0; index < original_data['features'].length; index++) {
                  const item3 = original_data['features'][index];
                  _data_ex_count_t += 1

                  if (!(filter_options === null || Matcher.filter(item3, filter_options))) {
                    continue
                  }

                  if (SDMData.Reference.length !== 0) {
                    let match_score = Matcher.filter_by_reference_on_import(item3, SDMConf.Reference)
                    // console.log('__match_score', match_score, item3, SDMConf.Reference)
                    if (match_score < 50) {
                      continue
                    }
                  }

                  _data_ex_count_i += 1
                  SDMData.Main.push(Matcher.select_attributes(item3, fields_to_export, input_file_index, _data_ex_count_i))

                  examples.push(original_data['features'][0])
                }
              }

              if (!!remote_file) {

                console.log('Remote fetch...', remote_file)

                try {
                  const _text = await remote_file._response.text();

                  //console.log('remote start....', _text)
                  if (_text && _text.length > 0) {
                    _parser_geojson_text(_text)
                  }
                } catch (error) {
                  console.error(file.name, error, remote_file._response.error);
                } finally {
                  return new Promise((resolve, reject) => {
                    cb(`Loaded ${file.name}`)
                    SDMData._SourceFilesFinished.add(data_file_uid)
                    resolve()
                  })
                }

              } else {
                let reader = new FileReader();
                reader.readAsText(file);
                // console.log('files_loaded', files_loaded, )
                // var input_file_index = files_loaded + 1
                let match_score = 0

                reader.onload = function () {
                  // console.log('loaded this', this)

                  try {

                    // Check for empty file
                    if (reader.result && reader.result.length > 0) {
                      _parser_geojson_text(reader.result)
                    }
                  } catch (error) {
                    console.error(file.name, error, reader.result)
                    // Expected output: ReferenceError: nonExistentFunction is not defined
                    // (Note: the exact output may be browser-dependent)
                  } finally {
                    return new Promise((resolve, reject) => {
                      cb(`Loaded ${file.name}`)
                      SDMData._SourceFilesFinished.add(data_file_uid)
                      resolve()
                    })
                  }

                  // files_loaded += 1
                }
                // files_loaded += 1
                reader.onerror = function () {
                  console.error(reader.error);
                  // files_loaded += 1
                };
              }

            };

            // END
          }

          processIndividualFile(
            file, remote_file, function (comment) {
              //console.log(comment)
            }
          )
        }

        // console.log('.,,.', input.files)

        if (remote_files && remote_files.length > 0) {
          // Is list of remote URLS (not from local disk)
          // console.warn("TODO")
          for (let index = 0; index < remote_files.length; index++) {
            const element = remote_files[index];

            // if (typeof element !== "string") {
            if (typeof element !== "string" && !Object.hasOwn(element, 'url')) {
              console.log(element)
              throw new Error("TODO implement complex list of data to load here");
              // @TODO deal with fallbacks
            }

            let _url = element
            if (element.url) {
              _url = element.url
            }

            let pseudo_file = {
              // @see https://stackoverflow.com/questions/511761
              name: _url.split('#')[0].split('?')[0].split('/').pop(),
              url: _url,
              size: -1,
              _content: null,
              _response: null,
              _remote: true
            }

            // @TODO maybe depending of the extension pass not the string
            //       but let the papaparse or geojsonl deal with ajax call

            try {
              const response = await fetch(_url);
              if (!response.ok) {
                throw new Error(`Response status: ${response.status}`);
              }

              // const _rext = await response.text();
              // console.log(_rext);
              pseudo_file._response = response
              // pseudo_file._content = await response.text();
              //pseudo_file._content = response.text();
            } catch (error) {
              console.error(error.message);
            }

            if (pseudo_file.name.endsWith(".yaml") || pseudo_file.name.endsWith(".yml")) {
              // skip configuration files
              // files_loaded += 1
            } else {
              await readFileMainLoop(null, pseudo_file)
              files_loaded += 1

              // if (!pseudo_file.name.endsWith(".csv") && !pseudo_file.name.endsWith(".tsv")) {
              //   // CSV/TSV have its own counter
              //   files_loaded += 1
              // }
            }

          }


        } else if (input !== false) {
          // Is list of files on local disk
          // console.log('Is list of files on local disk', input)

          for (let index = 0; index < input.files.length; index++) {
            const element = input.files[index];

            // console.log('_-', element.name)

            if (element.name.endsWith(".yaml") || element.name.endsWith(".yml")) {
              // skip configuration files
              console.log('skiped', element.name)
              files_loaded += 1
            } else {

              // console.log('processing...', element.name)
              await readFileMainLoop(element)
              files_loaded += 1
            }
          }
        } else {
          throw new Error("Bad logic");
        }

        let last_count = SDMData.Main.length

        let existCondition = setInterval(function () {
          let _totalfiles = -1
          if (input.files) {
            // This will fail if have any YAML
            _totalfiles = input.files.length

            for (let index = 0; index < input.files.length; index++) {
              const element = input.files[index];
              if (element.name.endsWith(".yaml", '.yml')) {
                _totalfiles = _totalfiles - 1
              }
            }

            // input.files.forEach(element => {

            // });
          } else {
            _totalfiles = remote_files.length

            // console.log('remote_files.lengthremote_files.length', remote_files)
          }

          // console.log('SDMData.Main.length', SDMData.Main.length)

          // console.log('>>>>>>>> existCondition <<<<<<<<')
          if (files_csv_finished !== files_csv_total) {
            console.log('files_csv_finished !== files_csv_total. Waiting...')

            // } else if (input.files.length == files_loaded && last_count == SDMData.Main.length) {
            // } else if (_totalfiles == files_loaded && last_count == SDMData.Main.length) {
          } else if (_totalfiles == files_loaded && last_count == SDMData.Main.length || SDMData._SourceFilesAll.length === SDMData._SourceFilesFinished.length) {
            // console.log("input.files.length == files_loaded");
            clearInterval(existCondition);

            UIb.data_ex_count_t.textContent = (new Intl.NumberFormat(_Etc.locale_number).format(_data_ex_count_t))
            UIb.data_ex_count_i.textContent = (new Intl.NumberFormat(_Etc.locale_number).format(_data_ex_count_i))

            if (_data_ex_count_i <= SDMConf.Preview.text) {
              UIb.data_active_count.textContent = new Intl.NumberFormat(_Etc.locale_number).format(_data_ex_count_i)
            } else {
              UIb.data_active_count.textContent = (new Intl.NumberFormat(_Etc.locale_number).format(SDMConf.Preview.text)) + ' (' + (new Intl.NumberFormat(_Etc.locale_number).format(_data_ex_count_i)) + ')'
            }
            // output.textContent = output_printer(SDMData.Main)


            SDMData.MainPreview = SDMData.Main.slice(0, SDMConf.Preview.map)
            //console.log('....SDMData.MainPreview', SDMData.Main, SDMData.MainPreview, SDMConf.Preview.map)
            // console.log('WorkingInputFiles', WorkingInputFiles)

            UI.ui_datasets_list(_Etc.WorkingInputFiles)

            UI.update_filter_delayed()

            // Disable the file input (user will need to re-load if needs to change)
            document.querySelector("#external-data-file").disabled = true
            document.querySelector("#data_ex_fields_exporter").disabled = true
            document.querySelector("#data_ex_filter").disabled = true
            document.querySelector("#import_reffile").disabled = true
            document.querySelector("#import_reffile_dist").disabled = true
            document.querySelector("#import_reffile_rules").disabled = true
            // update_map()

            // Hide extra column, since it will have no data to show
            if (SDMData.Auxiliary.length === 0) {
              document.querySelector("#ui_text_nopos_preview").checked = false
              //update_map()
              UI.update_ui()
            }

            //const t1 = profile_times[file.name]
            //const t2 = new Date()
            const diff_read_all = Helper.humanDiff(_Etc._readfile_start_time, new Date())
            console.log(`readFile (all files + processing) end: took: ${diff_read_all}`)

          } else {
            console.log('waiting input.files.length == files_loaded and last_count vs SDMData.Main.length stabilize', _totalfiles, files_csv_finished, files_loaded, last_count, SDMData.Main.length)
          }

          last_count = SDMData.Main.length
        }, 500); // check every 500ms

      } // function readFile(input) {


      /**
       * Caller to trigger file processing.
       * If false, assume was initialized by URL parametyers
       * If is reference, but one of the items is YAML, process the YAML first
       * Other cases: run as usual
       **/
      static readFilesOrParameters(input_or_false) {

        let remote_files = []

        if (input_or_false === false) {
          // console.log('todo')

          if ("data" in SDMConf.FromURIParameters && SDMConf.FromURIParameters.data.length > 0) {
            // console.log("SDMConf.FromURIParameters.data", SDMConf.FromURIParameters.data)
            remote_files = SDMConf.FromURIParameters.data
            // SDMConf._.add_config_remote

            // console.error('SDMConf.FromURIParameters', SDMConf.FromURIParameters)

            // SDMData._SourceFilesAll = 

            SDMConf.FromURIParameters.data.forEach(item => SDMData._SourceFilesAll.add(item))
          } else if ("conf" in SDMConf.FromURIParameters && SDMConf.FromURIParameters.conf.length > 0) {
            // Nothing here
          } else {
            throw new Error("Bad initialization, Neither is file upload or conf[]/data[] by URL parameters");
          }

        } else {

          Array.from(input_or_false.files).forEach(function (file) {
            if (file.name.endsWith(".yaml") || file.name.endsWith(".yml")) {
              // console.warn("TODO process YAML file first")

              const uid_promisse = file.name
              SDMConf._.add_config(false, uid_promisse)
              let reader = new FileReader();
              reader.readAsText(file);
              reader.onload = function () {

                SDMConf._.name = file.name.split(".").shift()
                SDMConf._.add_config(Configuration.object_from_yaml(reader.result), uid_promisse)

                //SDMConf._ = new Configuration(
                //  file.name.split(".").shift(), Configuration.object_from_yaml(reader.result))
                // console.warn("SDMConf._", SDMConf._)
              }
            } else {
              //Anything not a configuration file is assumed to be data file
              SDMConf._.add_data_file(file, true)

              // console.log('instanceof File', file instanceof File)
              SDMData._SourceFilesAll.add("file://" + file.name)
            }
          })
        }

        // console.log('SDMConf._.ready(console.log)')
        // SDMConf._.ready(console.log)

        SDMConf._.ready(function () {

          // SDMData._SourceFilesAll = SDMConf.FromURIParameters.data

          // SDMData._SourceFilesAll.add


          // console.log('SDMConf._.ready SDMConf._.remote_data', SDMConf._.remote_data)
          if (!!SDMConf._.remote_data) {
            SDMConf._.remote_data.forEach(function (item) {
              SDMData._SourceFilesAll.add(item)
            })

            Loader.readFile(input_or_false, SDMConf._.remote_data)
          } else {
            if (input_or_false === false && remote_files.length === 0) {
              UI.reportErrorCritical("No datasets to process", "Even if you loaded configurations, no dataset found on configurations/upload/URL parameters. Please restart.")
            }
            Loader.readFile(input_or_false, remote_files)
          }
        })

      }

      static readFileReference(input) {
        const import_reffile_dist = parseInt(document.querySelector("#import_reffile_dist").value)
        const import_reffile_dist2 = parseInt(document.querySelector("#import_reffile_dist2").value)
        const import_reffile_rules = MatchPrompt.parse_options_simple(document.querySelector("#import_reffile_rules").value, false)
        const import_reffile_rules_missing = Boolean(document.querySelector("#import_reffile_rules_missing").checked)
        console.log(input, import_reffile_dist, import_reffile_rules)

        SDMConf.Reference = {
          "distance": import_reffile_dist,
          "distance2": import_reffile_dist2,
          "rules": import_reffile_rules,
          "allow_missing_ref": import_reffile_rules_missing
        }

        if (import_reffile_rules && import_reffile_rules.length > 0) {
          SDMData.ReferenceStats.ref_items_no_tags = new Array(import_reffile_rules.length).fill(0);
          SDMData.ReferenceStats.ref_items_no_tags = new Array(import_reffile_rules.length).fill(0);
        }

        var filesref_loaded = 0
        // SDMData.Reference
        Array.from(input.files).forEach(function (file) {

          if (file.name.endsWith(".geojsonl")) {
            console.warn("Note: geojsonl not implented for reference files")
          }

          function processIndividualRefFile(
            file
          ) {
            let reader = new FileReader();
            reader.readAsText(file);
            var input_file_index = filesref_loaded + 1

            reader.onload = function () {
              // console.log('loaded this', this)

              let original_data = JSON.parse(reader.result)

              original_data['features'].forEach(function (item, index) {
                if ("__did" in item) {
                  delete item["__did"]
                }
                if ("__fid" in item) {
                  delete item["__fid"]
                }
                item["__rid"] = input_file_index
                item["__rfid"] = index + 1
                SDMData.Reference.push(item)
              })
              filesref_loaded += 1
            }
            reader.onerror = function () {
              console.log(reader.error);
              // files_loaded += 1
              filesref_loaded += 1
            };
          }

          processIndividualRefFile(
            file
          )
          // filesref_loaded += 1
        })


        let existConditionRef = setInterval(function () {

          // console.log('>>>>>>>> existCondition <<<<<<<<')
          if (input.files.length == filesref_loaded) {
            // console.log("input.files.length == files_loaded");
            clearInterval(existConditionRef);
            // update_map()

            console.log('SDMData.Reference done', SDMData.Reference)

            document.querySelector("#import_reffile").disabled = true
            document.querySelector("#import_reffile_dist").disabled = true
            document.querySelector("#import_reffile_dist2").disabled = true
            document.querySelector("#import_reffile_rules").disabled = true

            SDMData.ReferenceStats.ref_files = filesref_loaded
            SDMData.ReferenceStats.ref_items = SDMData.Reference.length

            SDMData.Reference.forEach(function (_item, index) {
              let have_pos = false
              let have_tags = false
              let one_lat = 0
              let one_lon = 0
              // https://datatracker.ietf.org/doc/html/rfc7946
              if (_item["geometry"]["coordinates"]) {
                let gtype = _item["geometry"]["type"]
                let pos = _item["geometry"]["coordinates"]
                if (Array.isArray(pos) && !Array.isArray(pos[0]) && pos.length >= 2) {
                  one_lat = pos[0]
                  one_lon = pos[1]
                } else if (Array.isArray(pos) && Array.isArray(pos[0]) && pos[0].length >= 2) {
                  one_lat = pos[0][0]
                  one_lon = pos[0][1]
                } else if (Array.isArray(pos) && Array.isArray(pos[0]) && Array.isArray(pos[0][0]) && pos[0][0].length >= 2) {
                  one_lat = pos[0][0][0]
                  one_lon = pos[0][0][1]
                }
                if (!!one_lat && !!one_lon) {
                  have_pos = true
                }
              }

              if (SDMConf.Reference.rules && SDMConf.Reference.rules.length) {
                let tags = []
                if (_item.hasOwnProperty("properties")) {
                  tags = Object.keys(_item["properties"])
                }

                SDMConf.Reference.rules.forEach(function (_rule, index) {
                  // if (!(tags.indexOf(_item) > -1)) {
                  let at_least_one_match = false
                  tags.forEach(function (prop_key) {
                    if (prop_key === _rule) {
                      at_least_one_match = true
                    }
                  })
                  if (!at_least_one_match) {
                    SDMData.ReferenceStats.ref_items_no_tags[index] += 1
                  }

                })
              }

              if (!have_pos) {
                SDMData.ReferenceStats.ref_items_no_pos += 1
              }
            })

            // https://stackoverflow.com/a/12075970/894546
            // Object.defineProperty(RegExp.prototype, "toJSON", {
            //   value: RegExp.prototype.toString
            // });
            document.querySelector("#import_reffile_output").innerHTML = JSON.stringify(
              { "statistics": SDMData.ReferenceStats, "options": SDMConf.Reference }, null, 4
            )

          } else {
            console.log('waiting input.files.length == filesref_loaded', input.files.length, filesref_loaded)
          }
        }, 250); // check every 250ms

      }

    }


    _MatchPromptTests = {
      a: `//MSf//@did=1
//MSf//@fid=1
//MS+//wikidata
//MS-//wikidata
wikidata=.+`
    }


    /**
     * Low level parsing of instructions for data matching
     **/
    class MatchPrompt {

      keywords = [
        "MSf",
        "MS+",
        "MS~",
        "MS", // Same as "MS~"
        "MS-",
        "FF", // Filter, focused in a dataset
        "FF?", // Filter, focused in a dataset (optional)
        "FA", // Filter, active
        "FA?", // Filter, active (?optional)
      ]

      distance_key = "@distance"

      constructor(prompt_text) {
        let result = this.preprocess_option(prompt_text)
        let result_object = this.process_option(prompt_text)


        this._rules = result_object

        console.log(this._rules)

        // # MSf - Match Strategy / focus (required: dataset, implicit assumes 1)
        // # MS+ - Match Strategy (+) strict match
        // # MS~ - Match Strategy (~) related match 
        // # MS- - Match Strategy (-) not related instruction / please ignore / give less relevance
        // # wikidata=.+ - (without?) A regex-like filter, before = is the key, after the = is either exact value or a regex
        // # ?phone=\+55.* - (with ? before the key) - Same as above, however if item does not have key phone, tolerate it
        // match_prompt: |
        //   //MSf//@did=1
        //   //MSf//@fid=1
        //   //MS+//wikidata
        //   //MS-//wikidata
        //   wikidata=.+
        //   ?phone=\+55.*

      }


      static _import_keys_renamer(item_object) {

        if (!item_object) {
          return item_object
        }
        //SDMOption.Renamer.item_object

        // console.log('iniciando')

        for (const [key, value] of Object.entries(item_object)) {
          // if (key in Object.keys(SDMOption.Renamer)) {
          if (Object.keys(SDMOption.Renamer).indexOf(key) > -1) {
            // console.log('fooi')
            // Object.defineProperty(o, new_key,
            // Object.getOwnPropertyDescriptor(o, old_key));
            // delete o[old_key];
            Object.defineProperty(item_object, SDMOption.Renamer[key][0],
              Object.getOwnPropertyDescriptor(item_object, key));
            delete item_object[key];
          }
        }

        return item_object
      }

      static _import_values_processor(item_object) {

        if (!item_object) {
          return item_object
        }

        if (Object.keys(item_object).indexOf("wikidata") > -1) {
          if (item_object["wikidata"].startsWith("http")) {
            let parts = item_object["wikidata"].split("entity/")
            if (parts.length === 2 && parts[1].startsWith("Q")) {
              item_object["wikidata"] = parts[1]
            }
          }
        }

        return item_object
      }

      /**
      * 
      * 
      **/
      static _import_expand_coordinates(item_object) {

        // Do not call this from something already GeoJSON
        if (!item_object) {
          return null
        }

      }

      static parse_options(text) {
        // return object with regexes for key-value
        let result = {}
        if (!text || text.trim().length === 0) {
          return null
        }
        text.split('\n').forEach(element => {
          element = element.trim()
          if (element.length > 0 && element.indexOf('//') === -1) {
            let parts = element.split('=')
            let key = parts.shift()
            let regex_str = parts.join('=')

            regex_str = MatchPrompt._parse_options_even_more_regex(key, regex_str)
            result[key] = new RegExp(regex_str, "i")
            // console.log(element)
          }

        });
        return result
      }

      static parse_options_simple(text, regex_like = true) {
        // return object with regexes for key-value
        let result = []
        if (!text || text.trim().length === 0) {
          return null
        }
        text.split('\n').forEach(element => {
          element = element.trim()
          if (element.length > 0 && element.indexOf('//') === -1) {
            // let parts = element.split('=')
            // let key = parts.shift()
            // let regex_str = parts.join('=')
            // result[key] = new RegExp(regex_str, "i")
            // result[key] = new RegExp(element, "i") // Not case sensitive
            // result[key] = new RegExp(element)
            if (regex_like) {
              result.push(new RegExp(element))
            } else {
              result.push(element.trim())
            }

            // console.log(element)
          }
        });
        return result
      }

      /**
       * return object with regexes for key-value
       * Only grab lines startign with // and syntax-like
       * //@did=3//addr:postcode=12345
       * Which means that only file-layer number 3 apply this rule
       * 
       * returns object if have anything meaningful, null otherwise
       * 
       * @example
       *    //@did=3//addr:postcode=12345
       *    name=hospital
       **/
      static parse_options_specific(text) {
        // return object with regexes for key-value
        let result_group = {}
        //let result = {}
        if (!text || text.trim().length === 0) {
          return null
        }
        text.split('\n').forEach(element => {
          element = element.trim()
          if (element.length > 0 && element.indexOf('//@did=') === 0) {
            let _parts2 = element.replace("//@did=", "").split("//")
            //console.log(_parts2)
            //if (parseInt(_parts2[0])) {
            if (parseInt(_parts2[0]) || _parts2[0] === "0") {

              // let did = _parts2[0].toString()
              let did = _parts2[0]
              if (!(`@did=${did}` in result_group)) {
                result_group[`@did=${did}`] = {}
              }

              //let parts = element.split('=')
              let parts = _parts2[1].split('=')
              let key = parts.shift()
              let regex_str = parts.join('=')

              regex_str = MatchPrompt._parse_options_even_more_regex(key, regex_str)
              // result[key] = new RegExp(regex_str, "i")
              result_group[`@did=${did}`][key] = new RegExp(regex_str, "i")
              // console.log(element)
            }

          }

        });
        if (Object.keys(result_group).length === 0) {
          return null
        }

        return result_group
      }

      preprocess_option(prompt_text) {
        let result = []
        if (!prompt_text || prompt_text.trim().length === 0) {
          return null
        }
        prompt_text.split('\n').forEach(element => {
          element = element.trim()
          if (element.length > 0) {
            if (element.indexOf('//') === -1) {
              if (element.indexOf('?') === 0) {
                result.push("//FA?//" + element.slice(0, 1) + str.slice(2))
              } else {
                result.push("//FA//" + element)
              }
            } else {
              result.push(element)
            }
          }
        });

        return result.join("\n")
      }

      process_option(prompt_text) {
        let result_object = {}
        let re_rules = /\/\/(?<RULE>.{2,3})\/\/(?<VALUE>.*)/
        if (!prompt_text || prompt_text.trim().length === 0) {
          return null
        }
        prompt_text.split('\n').forEach(element => {
          element = element.trim()

          let parts = re_rules.exec(element)

          if (parts) {
            if (parts.groups && this.keywords.indexOf(parts.groups.RULE) > -1) {
              if (!Object.hasOwn(result_object, parts.groups.RULE)) {
                result_object[parts.groups.RULE] = []
              }
              result_object[parts.groups.RULE].push(parts.groups.VALUE)
            } else {
              console.warn("prompt_text unknow keyword (or mere comment)", prompt_text, element)
            }
          }


          // console.log(parts)
          // console.log(parts.groups)


          // if (element.length > 0) {
          //   if (element.indexOf('//') === -1) {
          //     if (element.indexOf('?') === 0) {
          //       result.push("//FA?//" + element.slice(0, 1) + str.slice(2))
          //     } else {
          //       result.push("//FA//" + element)
          //     }
          //   } else {
          //     result.push(element)
          //   }
          // }
        });

        return result_object
      }

      /**
       * @TODO refactor this later as part of more complex
       *       tagging parsing. Likely move the keys into
       *       something that is configurable
       *       - fititnt 2024-08-07 16:22 BRT 
       * 
       **/
      static _parse_options_even_more_regex(key, regex_str) {

        // @TODO move this to configuration files
        let names = [
          'name', 'old_name', 'alt_name', 'official_name'
        ]

        let addrs = [
          'addr:street', 'addr:place'
        ]

        if (names.indexOf(key) > -1 || addrs.indexOf(key) > -1) {
          // https://stackoverflow.com/questions/990904/remove-accents-diacritics-in-a-string-in-javascript
          regex_str = regex_str.toLowerCase()
          // regex_str = regex_str.replace(/áàâ/)
          regex_str = regex_str.normalize("NFD").replace(/\p{Diacritic}/gu, "")
          let r = regex_str.replace(new RegExp(/[àáâãäå]/g), "a");
          r = r.replace(new RegExp(/æ/g), "ae");
          r = r.replace(new RegExp(/ç/g), "c");
          r = r.replace(new RegExp(/[èéêë]/g), "e");
          r = r.replace(new RegExp(/[ìíîï]/g), "i");
          r = r.replace(new RegExp(/ñ/g), "n");
          r = r.replace(new RegExp(/[òóôõö]/g), "o");
          r = r.replace(new RegExp(/œ/g), "oe");
          r = r.replace(new RegExp(/[ùúûü]/g), "u");
          regex_str = r.replace(new RegExp(/[ýÿ]/g), "y");
        }

        if (addrs.indexOf(key) > -1) {
          // https://stackoverflow.com/questions/990904/remove-accents-diacritics-in-a-string-in-javascript
          // regex_str = regex_str.lower()
          // regex_str = regex_str.replace(/áàâ/)
          // regex_str = regex_str.normalize("NFD").replace(/\p{Diacritic}/gu, "")
          let r = regex_str.replace(new RegExp(/^(avenida\s)/), "");
          r = r.replace(new RegExp(/^(av\.\s)/), "");
          r = r.replace(new RegExp(/^(av\s)/), "");
          r = r.replace(new RegExp(/^(travessa\s)/), "");
          r = r.replace(new RegExp(/^(alameda\s)/), "");
          r = r.replace(new RegExp(/^(rua\s)/), "");
          r = r.replace(new RegExp(/^(r\.\s)/), "");
          r = r.replace(new RegExp(/^(r\s)/), "");
          regex_str = r.replace(new RegExp(/^(praca\s)/), "");
        }

        // // Other dummy text
        // if (names.indexOf(key) > -1 || addrs.indexOf(key) > -1) {
        //   // https://stackoverflow.com/questions/990904/remove-accents-diacritics-in-a-string-in-javascript

        //   r = regex_str.replace(new RegExp(/\sde\s/g),"\s?d?e?\s");
        //   r = regex_str.replace(new RegExp(/\sda\s/g),"\s?d?a?\s");
        //   r = regex_str.replace(new RegExp(/\sdo\s/g),"\s?d?o?\s");

        //   // regex_str = r.replace(new RegExp(/[ýÿ]/g),"y");
        //   regex_str = r
        // }

        return regex_str

      }
    }

    // Matcher.
    class Matcher {

      static filter(item, options_general, options_specific, inverse = false) {
        // console.log('filter', item, options_general, options_specific)
        // if (options === null || !!options) {
        //   return !!inverse
        // }
        // console.log('filter', item, options)

        let options = options_general || {}
        let item_props = item["properties"]
        //let item_did = 

        // console.log('options before', item["__did"], item["__fid"], options, options_specific)

        // if (options_specific !== null && `@did=${item["__did"]}` in options_specific) {
        if (options_specific && options_specific[`@did=${item["__did"]}`]) {
          // console.log('options tem especifico', item["__did"], item["__fid"], options, options_specific[`@did=${item["__did"]}`])
          for (const [key, value] of Object.entries(options_specific[`@did=${item["__did"]}`])) {
            options[key] = value
          }
        } else {
          // console.log('options !!!NAO!! tem especifico', item["__did"], item["__fid"], options)
        }

        // console.log('options after', item["__did"], options, options_specific)

        let maches_count = 0
        let failed = false
        for (const [key, regex] of Object.entries(options)) {
          // if (!item_props.hasOwnProperty(key)) {
          if (!item_props.hasOwnProperty(key) && options[key] !== '') {
            return false
          }
          // let _regex = ''
          let value_str = item_props[key]
          if (typeof value_str !== 'sring') {
            value_str = value_str.toString()
          }
          // if 
          // console.log(item[key])
          if (!value_str.match(regex)) {
            // Maybe tolerage optional matches
            // maches_count += 1
            // maches_count += 1
            return false
          } else {
            maches_count += 1
          }
          // console.log(`${key}: ${value}`);
        }
        // console.log('passou', item["__did"], item["__fid"], options)
        return true
      }

      /**
       * Returns true if both objects are <= to maximum distance
       * Zero means exact position
       **/
      static filter_by_dist(item_geometry, ref_geometry_or_latlon, dist_in_m, default_invalid_item = true, default_ref_invalid = true) {

        // console.log('item_geometry', item_geometry, ref_latlon)
        // console.log(' filter by dist_in_m', dist_in_m)

        let item_latlon = null
        let ref_latlon = null

        // Tolerate the item not having geometry
        if (!item_geometry) {
          // return true

          // console.log('invalid item_geometry defaults to ', default_invalid_item)
          return default_invalid_item
        }
        // Does not colerate ref have no geometry
        if (!ref_geometry_or_latlon) {
          // return false

          // console.log('invalid ref_geometry_or_latlon defaults to ', default_ref_invalid)
          return default_ref_invalid
        }

        if (item_geometry["type"] == "Point") {
          item_latlon = item_geometry["coordinates"]
        } else if (item_geometry["type"] == "Polygon") {
          // THe ideal would be calculate the centroid, but here taking just first point
          item_latlon = item_geometry["coordinates"][0][0]
        } else {
          // @TODO test other types
          return default_invalid_item
        }

        if (Array.isArray(ref_geometry_or_latlon) && ref_geometry_or_latlon.length === 2) {
          ref_latlon = ref_geometry_or_latlon
        } else if (ref_geometry_or_latlon["type"] == "Point") {
          ref_latlon = ref_geometry_or_latlon["coordinates"]
        } else if (ref_geometry_or_latlon["type"] == "Polygon") {
          // THe ideal would be calculate the centroid, but here taking just first point
          ref_latlon = ref_geometry_or_latlon["coordinates"][0][0]
        } else {
          // @TODO test other types
          return default_ref_invalid
        }

        // if (dist_in_m === 0) {
        //   return item_latlon === ref_latlon
        // }

        // console.log(item_latlon, ref_latlon)

        const dist_in_km = Geo.haversineDistance(item_latlon, ref_latlon)

        // console.log('filter_by_dist', dist_in_km, dist_in_m, dist_in_km <= (dist_in_m / 1000))

        // if (!dist_in_m) {
        //   console.log('dist_in_m', dist_in_m)
        //   console.trace(dist_in_m)
        // }
        return dist_in_km <= (dist_in_m / 1000)
      }

      static filter_in_dids(item, dids_list) {
        // console.log('filter_in_dids', item, dids_list, item["__did"], dids_list.indexOf(item["__did"]) > -1)

        // Without explicitly list to filter, we assume its always pass
        //if (!dids_list || dids_list.length === 0) {
        // if (dids_list.length === 0) {
        //   return true
        // }

        // return false

        return dids_list.indexOf(item["__did"]) > -1
      }

      /**
       * Returns false if an item matched one or more itens from reference file
       * true means it did not matched
       **/
      static filter_substract_file(item, hide_did, hide_did_dist, hide_did_keys) {
        // console.log('filter_substract_file started', item, hide_did, hide_did_dist, hide_did_keys)

        if (hide_did === -1) {
          // No source file to substract: skip
          return true
        }

        if (hide_did_dist <= -1 && hide_did_keys.length === 0) {
          // console.log('filter_substract_file skipped 1')
          console.warn("filter_substract_file have clauses too flexible (any world distance, any tag)")
          // return true
          // document.getElementById("hide_did_output_log").innerText = "Universal exclusion?"
          _Etc.hide_did_affected = ["Universal exclusion? (any distance, any tagging)"]
          return false
        }

        // This should not happen
        if (item === null || !item["geometry"] || item["geometry"] === null) {
          // increase conter
          // console.log('hide_did_affected', hide_did_affected)
          // hide_did_affected[item["__did"]] -= 1
          // console.log('filter_substract_file skipped 2')
          return false
        }

        // console.log('filter_substract_file going to test', item)

        // As soon as we gind
        for (const source_item of SDMData.Main) {
          // No need to substract itens from subtracting file itself
          if (source_item["__did"] === hide_did) {
            // console.log('....', source_item["__did"], hide_did)
            let okay = true
            let has_distmatch = null
            let has_keymatch = null
            // @TODO implement tagging check

            if (hide_did_keys.length > 0) {

              // Keys exist, change from null to default false
              has_keymatch = false

              let _keys_matched = 0
              // console.log('before loop item vs source_item(file to match)', item, source_item)
              for (const testkey of hide_did_keys) {
                //console.log('testkey', source_item["properties"])
                if (testkey in source_item["properties"] && testkey in item["properties"]) {
                  let _testval = source_item["properties"][testkey].toString()
                  let _targetval = item["properties"][testkey].toString()
                  // console.log('test', _testval, _targetval)
                  if (_targetval.includes(";")) {
                    // console.log('includes;')
                    if (_targetval.split(";").indexOf(_testval)) {
                      // okay = false
                      _keys_matched += 1
                    }
                  } else if (_testval === _targetval) {
                    _keys_matched += 1
                    // console.log('prefect tagging match _testval, _targetval', _testval, _targetval)
                  }
                }
              }

              if (_keys_matched > 0) {
                //okay = false
                has_keymatch = true
              }
              // okay = (_keys_matched > 0)
            }

            // console.log('result taging for item', okay, item)

            // if (hide_did_dist > -1) {
            if (hide_did_dist > -1 && (has_keymatch === null || has_keymatch === true)) {
              has_distmatch = false
              if (Matcher.filter_by_dist(source_item["geometry"], item["geometry"], hide_did_dist)) {
                has_distmatch = true
                // console.log('prefect dist match', source_item, item)
              }
            }

            // if (okay === true) {
            if (
              (has_distmatch === null || has_distmatch === true) &&
              (has_keymatch === null || has_keymatch === true)
            ) {
              // Already have a match, count and abort imediatelly
              // increase conter
              // console.log('hide_did_affected, must not be included', hide_did_affected)
              // hide_did_affected[item["__did"]] -= 1
              _Etc.hide_did_affected[item["__did"]] -= 1
              return false
            }
          }
        }

        // No match means we let it run
        // console.warn('filter_substract_file allow this item', item)
        return true
      }

      /**
       * Returns likehood of item match by at least one item from reference dataset
       * 
       * (For sake of computation power, it only return the very first matched object)
       * 
       * @param item  GeoJSON Feature object
       * @returns Number  0 (very unlikely), > 90 stricter match
       */
      static filter_by_reference_on_import(item) {
        // return true
        let item_props = item["properties"]
        let item_pos = Geo.geojson_feature_centroid(item)
        let dist = -1
        // let already_failed = false
        let already_matched = null
        let score = 0

        SDMData.ReferenceStats.target_items += 1
        if (item_pos === null && (SDMConf.Reference.distance !== -1 || SDMConf.Reference.allow_missing_ref)) {
          SDMData.ReferenceStats.target_items_no_pos += 1
          // console.log('filter_by_reference_on_import item_pos', item_pos)
          return 0
        }

        let ref_item
        let ref_pos
        let ref_vs_item_dist
        let _dist_km
        let _tag_confidence = 0

        // console.log('filter_by_reference_on_import going to test', item)

        for (let index = 0; index < SDMData.Reference.length; index++) {
          ref_item = SDMData.Reference[index];
          ref_pos = Geo.geojson_feature_centroid(ref_item)
          if (!ref_pos) {
            console.log('ref_item failed centroid', ref_pos, item_pos)
            continue
          }

          _dist_km = Geo.haversineDistance(item_pos, ref_pos)
          // ref_vs_item_dist = _dist_km / 1000
          ref_vs_item_dist = _dist_km * 1000
          if (ref_vs_item_dist <= SDMConf.Reference.distance) {
            // Try match by tags
            _tag_confidence = Matcher.match_tags(ref_pos, item_pos, SDMConf.Reference.rules, true, true)

            if (_tag_confidence > 49) {
              already_matched = true
              break
            }

            // If failed by tags, but less stricter match allows, test agasinst
            // stricter distance

            if (ref_vs_item_dist <= SDMConf.Reference.distance2) {
              // console.log('stricter match', item, ref_vs_item_dist, _dist_km)
              already_matched = true
            }
          }
          // const dist_in_km = haversineDistance(item_pos, ref_latlon)
        }

        // if (SDMConf.Reference.rules && SDMConf.Reference.rules.length) {
        //   let tags = []
        //   if (item.hasOwnProperty("properties")) {
        //     tags = Object.keys(_item["properties"])
        //   }

        //   SDMConf.Reference.rules.forEach(function (_rule, index) {
        //     // if (!(tags.indexOf(_item) > -1)) {
        //     let at_least_one_match = false
        //     tags.forEach(function (prop_key) {
        //       if (prop_key.match(_rule)) {
        //         at_least_one_match = true
        //       }
        //     })
        //     if (!at_least_one_match) {
        //       SDMData.ReferenceStats.target_items_no_tags[index] += 1
        //     }
        //   })
        // }

        // SDMData.ReferenceStats.target_items_no_tags
        if (already_matched === true) {
          // @TODO make this more informative
          score = 100
        }
        // return true
        return score
      }

      static match_tags(ref_props, item_props, rules, missing_ref = true, missing_target = true) {
        if (!rules || rules.length === 0) {
          // return true
          return 100
        }

        let success = 0
        let skip = 0
        for (let index = 0; index < rules.length; index++) {
          const rule_key = rules[index];

          if (!(rule_key in ref_props)) {
            if (missing_ref) {
              skip += 1
            }
            continue
          }
          if (!(rule_key in ref_props)) {
            if (missing_target) {
              skip += 1
            }
            continue
          }
          // @TODO implement some normalization for names, addr:postcode, etc
          // levenshtein.js https://gist.github.com/andrei-m/982927
          if (ref_props[rule_key] === item_props[rule_key]) {
            success += 1
          }
        }

        if (success === rules.length) {
          return 100
        }

        if (success === 0 && skip !== rules.length) {
          return 0
        }

        if (success === 0 && skip === rules.length) {
          return 51
        }

        // @TODO
        return 0

      }


      static select_attributes(item, exportable_fields, input_file_index, temp_id, import_fields_anyifosm_nwr = true) {
        // @TODO keyval ; Only select attributes for properties
        let final = {
          '__did': input_file_index, // source file sequencial identifier (start from 1)
          '__fid': temp_id, // temporary unique id, serial, starts from 1
          'type': item['type'],
          'geometry': item['geometry'],
          'properties': {},
        }

        if ("@id" in item['properties'] && import_fields_anyifosm_nwr &&
          /^(node\/|way\/|relation\/|note\/)-?\d+/.test(item['properties']["@id"])) {
          final['properties'] = item["properties"]

        } else if (!exportable_fields) {
          final['properties'] = item["properties"]
        } else {

          for (const [key, value] of Object.entries(item['properties'])) {

            // We will always ignore empty strings
            if (value === "") {
              continue
            }

            if (_Etc._is_exportable.indexOf(key) > -1) {
              final['properties'][key] = value
            } else if (_Etc._is_not_exportable.indexOf(key) > -1) {
              // skip
            } else if (Matcher.key_exportable_or_not(key, exportable_fields)) {
              final['properties'][key] = value
            }
          }

          // exportable_fields.forEach(function (key_regex) {
          //
          //})
        }
        return final
      }

      static key_exportable_or_not(untested_key, exportable_fields) {
        let value_str = untested_key
        let at_least_one = false
        if (exportable_fields === null) {
          _Etc._is_exportable.push(untested_key)
          return true
        }

        if (typeof value_str !== 'sring') {
          value_str = value_str.toString()
        }

        exportable_fields.forEach(function (regex) {
          if (value_str.match(regex)) {
            _Etc._is_exportable.push(untested_key)
            at_least_one = true
            return true
            // break
          }
        })

        if (!at_least_one) {
          _Etc._is_not_exportable.push(untested_key)
          return false
        }

        return null

        // for (const [key, regex] of Object.entries(options)) {
        //   if (!item.hasOwnProperty(key)) {
        //     return false
        //   }
        //   // let _regex = ''
        //   let value_str = item[key]
        //   if (typeof value_str !== 'sring') {
        //     value_str = value_str.toString()
        //   }
        //   // if 
        //   // console.log(item[key])
        //   if (!value_str.match(regex)) {
        //     // Maybe tolerage optional matches
        //     // maches_count += 1
        //     // maches_count += 1
        //     return false
        //   } else {
        //     maches_count += 1
        //   }
      }

    }

    // UI.
    class UI {

      /**
       * Javascript that needs to run only once, after page finish load
       **/
      static init_ui() {
        // const memory_download = document.getElementById("memory_download");
        //const active_download = document.getElementById("active_download");
        // const export_download = document.getElementById("export_download");
        const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]')
        const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl))
        //memory_download.addEventListener("click", saveGeoJSONofMemory)
        // active_download.addEventListener("click", saveGeoJSONofActiveMemory)

        SDMConf._ = new Configuration()

        SDMConf._.add_config_remote(SDMConf.conf_init_file)

        export_download.addEventListener("click", UI.exportFile)
        if (SDMConf.conf_init_extras && SDMConf.conf_init_extras.length > 0) {
          SDMConf.conf_init_extras.map(item => SDMConf._.add_config_remote(item))
        }

        const export_filetype = document.querySelectorAll('input[type=radio][name=export_filetype]')
        export_filetype.forEach(function (element) {
          element.addEventListener("click", function () {
            let val = document.querySelector("input[type=radio][name=export_filetype]:checked").value
            document.querySelector("#export_fileext").innerText = val
          });
        });

        UI.ui_init_inputsize()

        UI.ui_init_urlparameters()
      }

      static encodeParamsforJOSM(item_props) {
        if (!item_props) {
          return ''
        }
        // const ignore = [
        //   /^@id$/
        // ]
        const ignore = [
          "@id"
        ]
        let result = []
        for (const key in item_props) {
          if (ignore.indexOf(key) === -1) {
            if (Object.hasOwnProperty.call(item_props, key)) {
              const element = item_props[key];
              //result.push(encodeURIComponent(key) + "=" + encodeURIComponent(element))
              // result.push(`${key}=${element}`.replace(" ", "+"))
              result.push(`${key}=${element}`)
              //result.push(encodeURIComponent(`${key}=${element}`))
              //result.push(encodeURIComponent(`${key}=${element}`))
            }
          }
        }

        // return result.join("|")
        return encodeURIComponent(result.join("|"))
      }

      /**
       * Use to show a popup modal. Intended only for very critical errors,
       * the type that would require reload the page and/or change
       * configurations.
       * 
       **/
      static reportErrorCritical(title, description) {
        let title_msg = "Critical: " + title

        console.error("reportErrorCritical", title, description)

        document.getElementById("criticalErrorModalLabel").innerText = title_msg
        // document.getElementById("critical_error_desc").innerText = description
        document.getElementById("critical_error_desc").innerHTML = description

        let modal = bootstrap.Modal.getOrCreateInstance(document.getElementById('criticalErrorModal'))
        modal.show();
        // modal.hide();

      }

      static onEachFeatureMatchClick(ev, fid, did) {
        ev.stopPropagation();
        ev.preventDefault();
        console.log("TODO: implement it", ev, fid, did)

        document.getElementById("filter_active_latlon").value = `@fid=${fid}`

      }

      static onEachFeatureJOSMClick(ev) {
        ev.stopPropagation();
        ev.preventDefault();
        const myRequest = new Request(ev.target.href);
        fetch(myRequest)
          .then(function (response) {
            console.log(`JSOM Remote: ${ev.target.href}`);
            //console.log(response.blob());
          }).catch((error) => {
            console.error("Is JOSM open? Is JOSM Remote enabled? (error: can't redirect to JOSM Remote Control)", error)
          });
      }

      static onEachFeature(feature, layer) {
        let title = ''
        let item_group = []
        let output = []
        let fid = feature["__fid"]
        let did = feature["__did"]

        // console.log('feature', feature)

        if (feature.properties) {



          // isso aqui deveria ser o popup
          if (feature.properties.name) {
            layer.bindTooltip(feature.properties.name);
          }

          // if (feature["geometry"]["type"] == "Point") {
          if (feature["geometry"]["type"] && feature["properties"]) {
            let _lon = parseFloat(feature["geometry"]["coordinates"][0])
            let _lat = parseFloat(feature["geometry"]["coordinates"][1])
            let _zoom = 17

            let _ed_id_extras = ''
            let _ed_josm_extras = ''
            //let _ed_josm_operation_1 = 'load_and_zoom'
            let _ed_josm_tags_1 = ''
            let _ed_l0_nwr = ''

            if (feature["properties"] && "@id" in feature["properties"] &&
              /^(node\/|way\/|relation\/)-?\d+/.test(feature["properties"]["@id"])
            ) {
              _ed_id_extras = '&' + feature['properties']["@id"].replace("/", "=")
              _ed_josm_extras = '&select=' + feature['properties']["@id"].replace("/", "")
              //_ed_josm_operation_1 = 'load_and_zoom'
              _ed_l0_nwr = feature['properties']["@id"]

            }

            // https://level0.osmz.ru/?url=node/240095754

            const josm_params = UI.encodeParamsforJOSM(feature['properties'])
            if (josm_params) {
              _ed_josm_tags_1 = "&addtags=" + josm_params
            }

            let _links = `<a href="#" target="_blank" onclick="UI.onEachFeatureMatchClick(event,${fid},${did})">Match!</a>`
            _links = _links + ` | <a href="https://osm.org/#map=${_zoom}/${_lat}/${_lon}" target="_blank">OSM</a>`
            _links = _links + ` | <a href="https://osm.org/edit#map=${_zoom}/${_lat}/${_lon}&photo_overlay=streetside,mapillary,kartaview${_ed_id_extras}" target="_blank">iD</a>`
            // _links = _links + ` | <a href="http://localhost:8111/${_ed_josm_operation_1}?left=${_lon - 0.0005}&right=${_lon + 0.0005}&top=${_lat + 0.0005}&bottom=${_lat - 0.0005}${_ed_josm_extras}${_ed_josm_tags_1}" target="_blank" onclick=onEachFeatureJOSMClick(event)>JOSM<sup>z</sup></a>`
            _links = _links + ` | <a href="http://localhost:8111/load_and_zoom?left=${_lon - 0.005}&right=${_lon + 0.005}&top=${_lat + 0.005}&bottom=${_lat - 0.005}${_ed_josm_extras}" target="_blank" onclick="UI.onEachFeatureJOSMClick(event)">JOSM<sup>z</sup></a>`
            _links = _links + ` | <a href="http://localhost:8111/add_node?lat=${_lat}&lon=${_lon}${_ed_josm_tags_1}" target="_blank" onclick="UI.onEachFeatureJOSMClick(event)">JOSM<sup>n</sup></a>`

            if (_ed_l0_nwr) {
              _links = _links + ` | <a href="https://level0.osmz.ru/?url=${_ed_l0_nwr}" target="_blank">level0</a>`
            }

            // http://localhost:8111/zoom?left=8.19&right=8.20&top=48.605&bottom=48.590

            //_links = _links + `| <a href="https://osm.org/#map=${_zoom}/${_lon}/${_lat}" target="_blank">OSM</a>`
            item_group.push(`// [@did=${feature["__did"]}; @fid=${feature["__fid"]}] // ${_links}`)
          } else {
            item_group.push(`// [@did=${feature["__did"]}; @fid=${feature["__fid"]}]`)
          }

          for (const [key, value] of Object.entries(feature['properties'])) {
            if (key == "@id" && (value.startsWith("node/") || value.startsWith("way/") || value.startsWith("relation/"))) {
              item_group.push(`${key}=<a href="https://osm.org/${value}" target="_blank">${value}</a>`)
            } else if (key.includes("wikidata") && (value.startsWith("Q") || value.startsWith("P"))) {
              item_group.push(`${key}=<a href="https://www.wikidata.org/wiki/${value}" target="_blank">${value}</a>`)
            } else {
              item_group.push(`${key}=${value}`)
            }
          }
          // output.push(item_group.join('\n'))

          // if (feature.properties.name) {
          //   // layer.bindPopup(feature.properties.name);
          //   // layer.bindPopup(output.join('\n\n'));
          //   layer.bindPopup(item_group.join('<br>'));
          // }
          layer.bindPopup(item_group.join('<br>'), { maxWidth: 500 });
        }

        // // does this feature have a property named popupContent?
        // if (feature.properties && feature.properties.popupContent) {
        //     layer.bindPopup(feature.properties.popupContent);
        // }
      }

      static output_printer(collection, _param1, _param2) {
        // let _maximum_displayed = 1000
        let _maximum_displayed = SDMConf.Preview.text
        let output = []
        collection.forEach(function (item) {
          // console.log('output_printer', item)
          let __did = item['__did']
          let __fid = item['__fid']
          _maximum_displayed -= 1
          if (_maximum_displayed >= 0) {
            let item_group = []

            if (item['_comment']) {
              item_group.push(`// note: [${item['_comment']}]`)
            }

            item_group.push(`// [@did=${__did}; @fid=${__fid}] ${JSON.stringify(item['geometry'])}`)

            for (const [key, value] of Object.entries(item['properties'])) {
              item_group.push(`${key}=${value}`)
            }
            output.push(item_group.join('\n'))
          }
        })
        return output.join('\n\n')
      }

      static saveGeoJSON(geojson_object, filename) {
        const blob = new Blob([JSON.stringify(geojson_object, null, 2)], {
          type: 'application/geo+json',
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${filename}.geojson`;
        a.click();
        URL.revokeObjectURL(url);
      };

      static saveGeoJSONTextSequences(geojson_object_list, filename) {
        const as_list = geojson_object_list.map((feature) => JSON.stringify(feature))


        // @TODO make it work with list of items
        // const blob = new Blob([JSON.stringify(geojson_object, null, 2)], {
        // const blob = new Blob([as_list.join("␞\n")], {
        const blob = new Blob([as_list.join(String.fromCharCode(30, 10))], {
          type: 'application/geo+json-seq',
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${filename}.geojsonl`;
        a.click();
        URL.revokeObjectURL(url);
      };

      static saveGeoJSONofActiveMemory() {
        let result = {
          "type": "FeatureCollection",
          "_meta": {
            "sources": [],
            "import_filters": "",
            "import_fields": "",
            "active_filter_tags": "",
          },
          "features": []
        }

        // @TODO implement full download, not merely preview
        _Etc.WorkingInputFiles.forEach(function (item) {
          result["_meta"]["sources"].push({
            name: item["name"],
            lastModified: item["lastModified"],
            lastModifiedDate: item["lastModifiedDate"],
            size: item["size"],
          })
        })

        result["_meta"]["import_filters"] = document.getElementById("data_ex_filter").value
        result["_meta"]["import_fields"] = document.getElementById("data_ex_fields_exporter").value
        result["_meta"]["active_filter_tags"] = document.getElementById("filter_active_simple").value
        result["_meta"]["active_filter_refence"] = document.getElementById("filter_active_latlon").value
        result["_meta"]["active_filter_refence_distance"] = document.getElementById("filter_active_latlon_dist").value

        SDMData.Main.forEach(function (item) {
          result["features"].push(item)
        })

        // saveGeoJSON({ test: 'is passed' }, 'testJsonFile');
        UI.saveGeoJSON(result, 'osm-fm__active-memory(preview-only)');
      };

      static saveGeoJSONofMemory(filename = 'osm-fm__working-memory', filesuffix = '.geojson') {
        let result = {
          "type": "FeatureCollection",
          "_meta": {
            "sources": [],
            "import_filters": "",
            "import_fields": "",
          },
          "features": []
        }

        _Etc.WorkingInputFiles.forEach(function (item) {
          result["_meta"]["sources"].push({
            name: item["name"],
            lastModified: item["lastModified"],
            lastModifiedDate: item["lastModifiedDate"],
            size: item["size"],
          })
        })

        result["_meta"]["import_filters"] = document.getElementById("data_ex_filter").value
        result["_meta"]["import_fields"] = document.getElementById("data_ex_fields_exporter").value

        SDMData.Main.forEach(function (item) {
          result["features"].push(item)
        })

        // saveGeoJSON({ test: 'is passed' }, 'testJsonFile');
        // saveGeoJSON(result, 'osm-fm__working-memory');

        console.log('UI.saveGeoJSONofMemory', result, filename, filesuffix, filesuffix === '.geojson', filesuffix === '.geojsonl')

        if (filesuffix === '.geojson') {
          console.log('UI.saveGeoJSONofMemory todo saveGeoJSON', filesuffix)
          UI.saveGeoJSON(result, filename);
        } else if (filesuffix === ".geojsonl") {
          console.log('UI.saveGeoJSONofMemory todo saveGeoJSONTextSequences', filesuffix)
          UI.saveGeoJSONTextSequences(result["features"], filename);
        } else {
          throw Error("UI.saveGeoJSONofMemory err", filename, filesuffix)
        }
      };

      static exportFile() {
        const filename = document.querySelector("#export_filename").value
        const filesuffix = document.querySelector("#export_fileext").innerText
        const filetype = document.querySelector("input[type=radio][name=export_filetype]:checked").value
        const content = document.querySelector("input[type=radio][name=export_content]:checked").value

        // console.log("TODO exportFile", filename, filesuffix, filetype)

        UI.saveGeoJSONofMemory(filename, filesuffix)
      }


      static ui_clean(event) {
        // console.log(event)
        //console.log(event.target.id)
        if (event.target.id === "v_meta") {
          console.log('ui_clean toggle: show/hide bars, title of app, etc')
          if (event.target.checked) {
            document.querySelectorAll('.v_meta-element').forEach(x => x.classList.remove('d-none'))
          } else {
            document.querySelectorAll('.v_meta-element').forEach(x => x.classList.add('d-none'))
          }
        }
        if (event.target.id === "v_filter_up") {
          console.log('ui_clean toggle: show/hide filters/selectors at the top')
          if (event.target.checked) {
            document.querySelectorAll('.v_filter_up-element').forEach(x => x.classList.remove('d-none'))
          } else {
            document.querySelectorAll('.v_filter_up-element').forEach(x => x.classList.add('d-none'))
          }
        }
        if (event.target.id === "v_filter_bottom") {
          console.log('ui_clean toggle: show/hide filters/selectors at bottom')
          if (event.target.checked) {
            document.querySelectorAll('.v_filter_bottom-element').forEach(x => x.classList.remove('d-none'))
          } else {
            document.querySelectorAll('.v_filter_bottom-element').forEach(x => x.classList.add('d-none'))
          }
        }
        if (event.target.id === "v_map_autofocus") {
          console.log('ui_clean toggle: enable/disable map autofocus when filters change')
        }
      }

      static ui_datasets_list(working_files) {
        // console.log('ui_datasets_list')
        const map_dataset_list = document.getElementById('map_dataset_list')

        if (_Etc.enabled_files.indexOf(-1) === 0) {
          // needs initialization
          _Etc.enabled_files = []
          working_files.forEach(function (item, index) {
            _Etc.enabled_files.push(index + 1)
          })
        }
        _Etc.enabled_files
        let _html = []
        _html.push(`<h2 class="visually-hidden">Filtros</h2>`)
        _html.push(`<div class="row v_filter_bottom-element">`)
        _html.push(`  <div class="col">`)
        _html.push(`  <h3 class="h5">Loaded datasets</h3>`)
        working_files.forEach(function (item, index) {
          // _html.push(`<li><img height="41" width="25" src="${ui_map_pin_images(index)}"/> ${item["name"]}</li>`)
          _html.push(`<div class="form-check form-switch">
  <input class="form-check-input" type="checkbox" role="switch" id="check__did${index + 1}" data-did="${index + 1}" checked onchange="UI.ui_datasets_list_event(event)">
  <label class="form-check-label" for="check__did${index + 1}">
    <img height="41" width="25" src="${UI.ui_map_pin_images(index + 1)}"/>
    [${UI.ui_datasets_list_did_itens_count(index + 1)}]
    ${item["name"]}
  </label>
</div>`)
        })

        _html.push(`  </div>`)
        _html.push(`  <div class="col">`)
        _html.push(`    <div class="row">`)
        _html.push(`      <h3 class="h5">Datasets used to hide others</h3>`)
        _html.push(`      <select class="form-select" aria-label="Dataset to substract" onchange="UI.ui_datasets_list_event(event)" id="hide_did">
  <option selected value="-1">- Dataset to substract - </option>`)
        working_files.forEach(function (item, index) {
          // _html.push(`<li><img height="41" width="25" src="${ui_map_pin_images(index)}"/> ${item["name"]}</li>`)
          _html.push(`<option value="${index + 1}">${item["name"]}</option>`)
        })
        _html.push(`      </select>`)
        _html.push(`    </div>`)
        _html.push(`    <div class="row">`)
        _html.push(`      <div class="col">`)
        _html.push(`        <div class="input-group mb-3">
  <span class="input-group-text" id="">Distância (m)</span>
  <input type="text" class="form-control" placeholder="-1 to disable" id="hide_did_dist" aria-label="Distancia" value="25" onchange="UI.ui_datasets_list_event(event)">
</div>`)
        _html.push(`      </div>`)
        _html.push(`      <div class="col">`)
        _html.push(`        <div class="input-group mb-3">
  <span class="input-group-text" id="">Keys</span>
  <input type="text" class="form-control" placeholder="phone,email,ref:vatin" aria-label="Key" value="phone,email,ref:vatin" id="hide_did_keys"  onchange="UI.ui_datasets_list_event(event)">
</div>`)
        _html.push(`        </div>`)
        _html.push(`      </div>`)
        _html.push(`    <div>`)
        _html.push(`      <output id="hide_did_output_log"></output>`)
        _html.push(`    </div>`)
        _html.push(`    <div class="row">`)
        _html.push(`      <h3 class="h5">Dataset foco</h3>`)
        _html.push(`      <select class="form-select" aria-label="Dataset de foco" onchange="UI.ui_datasets_list_event(event)" id="focus_did">
  <option selected value="-1">- Dataset de foco - </option>`)
        working_files.forEach(function (item, index) {
          // _html.push(`<li><img height="41" width="25" src="${ui_map_pin_images(index)}"/> ${item["name"]}</li>`)
          _html.push(`<option value="${index + 1}">${item["name"]}</option>`)
        })
        _html.push(`      </select>`)
        _html.push(`  </div>`)
        _html.push(`</div>`)
        //_html.push(`</div>`)

        //map_dataset_list.innerHTML = "TODO"
        map_dataset_list.innerHTML = _html.join("\n")

        UI.update_ui_refpos()
        UI.update_filter_delayed()
      }


      static ui_datasets_list_did_itens_count(did) {
        let count = 0
        SDMData.Main.forEach(function (item) {
          if (item["__did"] == parseInt(did)) {
            count += 1
          }
        })

        return new Intl.NumberFormat().format(count)
      }
      static ui_datasets_list_event(event) {
        // console.log('ui_datasets_list_event', event)

        _Etc.hide_did = parseInt(document.querySelector("#hide_did").value)
        _Etc.hide_did_dist = parseInt(document.querySelector("#hide_did_dist").value)
        _Etc.hide_did_keys = document.querySelector("#hide_did_keys").value.split(",").map(x => x.trim()).filter(x => x)
        _Etc.focus_did = parseInt(document.querySelector("#focus_did").value)

        if (_Etc.hide_did > -1) {
          document.querySelector(`#check__did${_Etc.hide_did}`).checked = false
        }

        if (_Etc.focus_did > -1) {
          document.querySelector(`#check__did${_Etc.focus_did}`).checked = true
          if (_Etc.hide_did === _Etc.focus_did) {
            _Etc.hide_did = -1
            document.querySelector("#hide_did").value = "-1"
          }
        }

        //filter_dids = Array.from(document.querySelectorAll("#map_dataset_list .form-check-input:checked")).map((element => parseInt(element.dataset.did)))
        _Etc.enabled_files = Array.from(document.querySelectorAll("#map_dataset_list .form-check-input:checked")).map((element => parseInt(element.dataset.did)))

        UI.update_filter_delayed()
        // update_map()
        //if (document.getElementById('ui_map_preview_realtime').checked) {
        //  update_map()
        //}
        // if (document.getElementById('ui_map_preview').checked) {
        //   update_map()
        // }
      }


      /**
       * This will check if URI have paramaters, such as data files in data[]
       * ?data[]=https://example.org/file1.geojson&data[]=https://example.org/file2.csv
       * and if find, will populate SDMConf and trigger the initialization
       * without user click
       **/
      static ui_init_urlparameters() {

        if (document.location.search.length > 1) {

          let simple_conf = {
            data: [],
            conf: [],
          }
          let trigger_init = false

          const searchParams = new URLSearchParams(document.location.search.replace(/^\?/, ""));


          for (const p of searchParams) {
            // console.log(p);
            if (p[0] === "data[]") {
              simple_conf.data.push(p[1])
              trigger_init = true
            }
            if (p[0] === "conf[]") {
              simple_conf.conf.push(p[1])
              // console.log('SDMConf._', SDMConf._)
              SDMConf._.add_config_remote(p[1])
              trigger_init = true

            }
          }

          // console.log('ui_init_urlparameters', simple_conf)
          SDMConf.FromURIParameters = simple_conf
          if (trigger_init) {
            Loader.readFilesOrParameters(false)
          }
        }

        return false
      }

      static ui_init_export() {
        // export_filetype

      }


      static ui_init_inputsize() {

        const uploadInput = document.getElementById("external-data-file");

        uploadInput.addEventListener(
          "change",
          () => {
            // Calculate total size
            let numberOfBytes = 0;
            for (const file of uploadInput.files) {
              numberOfBytes += file.size;
            }

            // Approximate to the closest prefixed unit
            const units = [
              "B",
              "KiB",
              "MiB",
              "GiB",
              "TiB",
              "PiB",
              "EiB",
              "ZiB",
              "YiB",
            ];
            const exponent = Math.min(
              Math.floor(Math.log(numberOfBytes) / Math.log(1024)),
              units.length - 1
            );
            const approx = numberOfBytes / 1024 ** exponent;
            const output =
              exponent === 0
                ? `${numberOfBytes} bytes`
                : `${approx.toFixed(3)} ${units[exponent]
                } (${numberOfBytes} bytes)`;

            document.getElementById("fileNum").textContent =
              uploadInput.files.length;
            document.getElementById("fileSize").textContent = output;
          },
          false
        );
      }

      static ui_map_pin_images(did) {
        // const _baseurl_icons = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-'
        const _baseurl_icons = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-'
        const list_icons = [
          _baseurl_icons + "blue.png",
          _baseurl_icons + "green.png",
          _baseurl_icons + "gold.png",
          _baseurl_icons + "orange.png",
          _baseurl_icons + "red.png",
          _baseurl_icons + "yellow.png",
          _baseurl_icons + "violet.png",
          _baseurl_icons + "grey.png",
          _baseurl_icons + "blue.png",
          _baseurl_icons + "black.png"
        ]
        const modulo = did % list_icons.length
        return list_icons[modulo]
      }
      /**
       * 
       * Run ideally only once after all the files are ready to be rendered.
       * Some async cases may be simpler to just run again
       * (doing this for CSV asyng)
       * 
       **/
      static ui_reload_after_import = () => {

      }

      static update_filter_delayed() {
        _Etc.debounceAttemptedCount += 1
        // console.log('update_filter_delayed', debounceAttemptedCount, (new Date()))
        Helper.debounce(UI.update_filter_imediate, 100)
      }

      static update_filter_delayed_opt(text) {
        let parsed_general = null
        let parsed_specific = null
        if (text.indexOf('=') === -1) {
          parsed_general = MatchPrompt.parse_options_simple(text)
          // console.log('update_filter_delayed_opt simple', text, parsed)
        } else {
          parsed_general = MatchPrompt.parse_options(text)
          // console.log('update_filter_delayed_opt full', text, parsed)
        }
        parsed_specific = MatchPrompt.parse_options_specific(text)
        return [parsed_general, parsed_specific]
      }

      static update_filter_imediate() {

        // console.log('update_filter_imediateZ  >>>>', (new Date()))
        _Etc.debounceRealCount += 1
        // console.log('update_filter_imediate Calls : ' + debounceRealCount);

        // console.log('update_filter_imediate ___ -2')

        // console.log('update_filter_delayed started')
        let items_to_display = []
        // SDMData.MainPreview = []
        let _data_active_count = 0
        // let parsed_1 = update_filter_delayed_opt(filter_active_simple.value)

        // try {
        //   const _filter_parts = update_filter_delayed_opt(filter_active_simple.value)
        // } catch (error) {
        //   console.error(error)

        // }
        const _filter_parts = UI.update_filter_delayed_opt(UIb.filter_active_simple.value)

        // console.log('update_filter_imediate ___ -1', _filter_parts)
        // const _filter_parts = update_filter_delayed_opt(filter_active_simple.value)

        const parsed_general = _filter_parts[0]
        const parsed_specific = _filter_parts[1]
        // console.log('update_filter_imediate ___ 0')
        //let dids_list = null
        // let dids_list = Array.from(document.querySelectorAll("#map_dataset_list .form-check-input:checked")).forEach((element => console.log(element.dataset.did)))
        // console.log('compiled regex filter', parsed_1)

        if (_Etc.hide_did >= 0) {
          // Prefill hide_did_affected with zeroes
          _Etc.hide_did_affected = new Array(_Etc.WorkingInputFiles.length).fill(0);
        }

        // console.log('refpoint_distance', refpoint_distance)

        // console.log('update_filter_imediate ___ 1')

        // items_to_display = []
        SDMData.MainPreview = []

        // **** Data with coordinates ***
        for (let index = 0; index < SDMData.Main.length; index++) {
          const item = SDMData.Main[index];

          // Disabled files filter
          if (!Matcher.filter_in_dids(item, _Etc.enabled_files)) {
            continue
          }

          // tagging filter
          if (!Matcher.filter(item, parsed_general, parsed_specific)) {
            continue
          }
          // // filter by distance
          if (!(Matcher.filter_by_dist(item['geometry'], _Etc.refpoint_latlon, _Etc.refpoint_distance))) {
            continue
          }
          // // Use a reference dataset to filter elements from another dataset. CPU intensive
          if (!Matcher.filter_substract_file(item, _Etc.hide_did, _Etc.hide_did_dist, _Etc.hide_did_keys)) {
            continue
          }

          _data_active_count += 1

          if (SDMData.MainPreview.length <= SDMConf.Preview.map) {
            SDMData.MainPreview.push(item)
          } else if (_Etc.focus_did === item["__did"] && SDMData.MainPreview.length <= (2 * SDMConf.Preview.map)) {
            // If one dataset is focused, we allow up to 2 times the preview size
            // this could help when have two very large datasets, so the smaller
            // one does not keep being removed
            SDMData.MainPreview.push(item)
          }
        }
        // items_to_display = []
        SDMData.AuxiliaryPreview = []

        // **** Data with coordinates ***
        for (let index = 0; index < SDMData.Auxiliary.length; index++) {
          const item = SDMData.Auxiliary[index];

          // Disabled files filter
          if (!Matcher.filter_in_dids(item, _Etc.enabled_files)) {
            continue
          }

          // tagging filter
          if (!Matcher.filter(item, parsed_general, parsed_specific)) {
            continue
          }
          // // filter by distance
          if (!(Matcher.filter_by_dist(item['geometry'], _Etc.refpoint_latlon, _Etc.refpoint_distance))) {
            continue
          }
          // // Use a reference dataset to filter elements from another dataset. CPU intensive
          if (!Matcher.filter_substract_file(item, _Etc.hide_did, _Etc.hide_did_dist, _Etc.hide_did_keys)) {
            continue
          }

          _data_active_count += 1

          if (SDMData.AuxiliaryPreview.length <= SDMConf.Preview.map) {
            SDMData.AuxiliaryPreview.push(item)
          } else if (_Etc.focus_did === item["__did"] && SDMData.AuxiliaryPreview.length <= (2 * SDMConf.Preview.map)) {
            // If one dataset is focused, we allow up to 2 times the preview size
            // this could help when have two very large datasets, so the smaller
            // one does not keep being removed
            SDMData.AuxiliaryPreview.push(item)
          }
        }

        // Data without coordinates
        // @TODO

        // SDMData.MainPreview = items_to_display

        // console.log('update_filter_imediate ___ 2')
        // data_ex_count_t.textContent = _data_ex_count_t
        // data_active_count.textContent = _data_active_count
        // data_active_count.textContent = new Intl.NumberFormat(locale_number).format(_data_active_count)
        UIb.data_active_count.textContent = (new Intl.NumberFormat(_Etc.locale_number).format(SDMData.MainPreview.length)) + ' (' + (new Intl.NumberFormat(_Etc.locale_number).format(_data_active_count)) + ')'
        // output.textContent = output_printer(items_to_display)
        // output.textContent = output_printer(items_to_display)

        // console.log('SDMData.MainPreview', SDMData.MainPreview)
        //SDMData.MainPreview = items_to_display.slice(0, SDMConf.Preview.map)

        if (_Etc.hide_did >= 0) {
          // Prefill hide_did_affected with zeroes
          document.querySelector("#hide_did_output_log").innerHTML = JSON.stringify(_Etc.hide_did_affected)
          // hide_did_affected = new Array(WorkingInputFiles.length).fill(0);
        } else {
          document.querySelector("#hide_did_output_log").innerHTML = ''
        }

        if (document.getElementById('ui_text_preview').checked) {
          UIb.output.value = UI.output_printer(SDMData.MainPreview)
        }

        if (document.getElementById('ui_text_nopos_preview').checked) {
          UIb.output2.value = UI.output_printer(SDMData.AuxiliaryPreview)
        }

        if (document.getElementById('ui_map_preview').checked) {
          update_map()
        }

        // SDMData.MainPreview = items_to_display

        // let freeBusLayer = L.geoJSON(SDMData.MainPreview).addTo(map);
        // output.textContent = output_printer_map(items_to_display)
      }


      /**
       * Javascript events that need to respond to changes in the input,
       * mostly after files are loaded, but user is changing filters
       **/
      static update_ui() {
        // const ui_filter_extras = document.getElementById("ui_filter_extras");
        // const ui_text_preview = document.getElementById("ui_text_preview");
        const ui_map_preview = document.getElementById("ui_map_preview");
        const ui_text_nopos_preview = document.getElementById("ui_text_nopos_preview");
        // const ui_map_preview_realtime = document.getElementById("ui_map_preview_realtime");

        if (ui_text_nopos_preview.checked) {
          document.querySelector("#output_items_spatial").classList = "col-xl-4 col-lg-6"
          document.querySelector("#output_items_nonspatial").classList = "col-xl-4 col-lg-6"
          document.querySelector("#map-container").classList = "col-xl-4"
          map.invalidateSize()
        } else {
          document.querySelector("#output_items_spatial").classList = "col-xl-4"
          document.querySelector("#output_items_nonspatial").classList = "d-none"
          document.querySelector("#map-container").classList = "col-xl-8"
          map.invalidateSize()
        }

      }

      static update_ui_refpos() {
        const filter_active_latlon = document.getElementById("filter_active_latlon").value;
        const filter_active_latlon_dist = parseInt(document.getElementById("filter_active_latlon_dist").value);


        // @fid=98
        if (filter_active_latlon.includes("@fid=")) {
          let _parts = filter_active_latlon.trim().split("@fid=")
          let _fid = parseInt(_parts[1])
          // console.log('@fid', filter_active_latlon, _parts)

          SDMData.Main.some(function (item, index) {
            if (item["__fid"] == _fid) {
              // Only if is Point, others may not be excatly on center
              _Etc.refpoint_latlon = item['geometry']['coordinates']
              return true
            }
          })

        } else if (filter_active_latlon.includes("#map=")) {
          // example https://www.openstreetmap.org/edit#map=18/-30.15178/-51.13461
          // example parse https://osm.org/edit#map=18/-30.15178/-51.13461
          let _parts = filter_active_latlon.split("#map=")
          let _parts2 = _parts[1].split("/") // zoom, lon, lat
          // On URL, is the opposite order
          _Etc.refpoint_latlon = [parseFloat(_parts2[2]), parseFloat(_parts2[1])]
        } else {
          const _latlon = filter_active_latlon.split(',')
          if (_latlon.length != 2) {
            _Etc.refpoint_latlon = null
          } else {
            _Etc.refpoint_latlon = [parseFloat(_latlon[0]), parseFloat(_latlon[1])]
            // refpoint_longitude = _latlon[0]
            // refpoint_longitude = _latlon[1]
          }
        }

        _Etc.refpoint_distance = filter_active_latlon_dist
      }

    }

    // const loaderExternal = document.getElementById("uploadInput");
    // const loaderExternalAct = document.getElementById("external-data-btn");
    // const map = L.map('map').setView([39.74739, -105], 13);

    // const tiles_osm = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
    //   maxZoom: 19,
    //   attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
    //   // }).addTo(map);
    // });

    // const tiles_openTopoMap = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
    //   maxZoom: 19,
    //   attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
    // });

    // const tiles_bdgex = L.tileLayer.wms('https://bdgex.eb.mil.br/mapcache?', {
    //   // layers: 'ieders_mi290_portao'
    //   layers: 'ctmmultiescalas_mercator',
    //   // attribution: 'https://bdgex.eb.mil.br/',
    //   attribution: '<a target="_blank" href="https://bdgex.eb.mil.br/">Cartas Topográficas do Exército Brasileiro</a>',
    //   maxZoom: 20
    // })

    // const overlay_bdgex_hidrigrafia = L.tileLayer.wms('https://bdgex.eb.mil.br/mapcache?', {
    //   // layers: 'ieders_mi290_portao'
    //   layers: 'Multiescala_Hidrografia',
    //   format: 'image/png',
    //   transparent: true,
    //   tiled: true,
    //   // srs: 'EPSG:4326',
    //   crs: L.CRS.EPSG4326,
    //   // attribution: 'https://bdgex.eb.mil.br/',
    //   attribution: 'Camada de hidrografia por <a target="_blank" href="https://bdgex.eb.mil.br/">BDGEx</a>',
    //   // maxNativeZoom: 17,
    //   maxNativeZoom: 16,
    //   maxZoom: 20
    // })

    // https://bdgex.eb.mil.br/mapcache?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetMap&FORMAT=image%2Fpng&TRANSPARENT=true&LAYERS=Multiescala_Relevo&TILED=true&WIDTH=256&HEIGHT=256&SRS=EPSG%3A4326&STYLES=&BBOX=-51.34506483742349%2C-29.700926167632637%2C-51.32474623462002%2C-29.680607564829167
    // const overlay_bdgex_relevo = L.tileLayer.wms('https://bdgex.eb.mil.br/mapcache?', {
    //   // layers: 'ieders_mi290_portao'
    //   layers: 'Multiescala_Relevo',
    //   format: 'image/png',
    //   transparent: true,
    //   tiled: true,
    //   // srs: 'EPSG:4326',
    //   crs: L.CRS.EPSG4326,
    //   // attribution: 'https://bdgex.eb.mil.br/',
    //   attribution: 'Camada de relevo por <a target="_blank" href="https://bdgex.eb.mil.br/">BDGEx</a>',
    //   // maxNativeZoom: 17,
    //   maxNativeZoom: 16,
    //   maxZoom: 20
    // })


    let _VarsMap = {
      // loaderExternal: document.getElementById("uploadInput"),
      // loaderExternalAct: document.getElementById("external-data-btn"),
      tiles_osm: L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
        // }).addTo(map);
      }),
      tiles_openTopoMap: L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
      }),
      tiles_bdgex: L.tileLayer.wms('https://bdgex.eb.mil.br/mapcache?', {
        // layers: 'ieders_mi290_portao'
        layers: 'ctmmultiescalas_mercator',
        // attribution: 'https://bdgex.eb.mil.br/',
        attribution: '<a target="_blank" href="https://bdgex.eb.mil.br/">Cartas Topográficas do Exército Brasileiro</a>',
        maxZoom: 20
      }),
      overlay_bdgex_hidrigrafia: L.tileLayer.wms('https://bdgex.eb.mil.br/mapcache?', {
        // layers: 'ieders_mi290_portao'
        layers: 'Multiescala_Hidrografia',
        format: 'image/png',
        transparent: true,
        tiled: true,
        // srs: 'EPSG:4326',
        crs: L.CRS.EPSG4326,
        // attribution: 'https://bdgex.eb.mil.br/',
        attribution: 'Camada de hidrografia por <a target="_blank" href="https://bdgex.eb.mil.br/">BDGEx</a>',
        // maxNativeZoom: 17,
        maxNativeZoom: 16,
        maxZoom: 20
      }),
      overlay_bdgex_hidrigrafia: L.tileLayer.wms('https://bdgex.eb.mil.br/mapcache?', {
        // layers: 'ieders_mi290_portao'
        layers: 'Multiescala_Hidrografia',
        format: 'image/png',
        transparent: true,
        tiled: true,
        // srs: 'EPSG:4326',
        crs: L.CRS.EPSG4326,
        // attribution: 'https://bdgex.eb.mil.br/',
        attribution: 'Camada de hidrografia por <a target="_blank" href="https://bdgex.eb.mil.br/">BDGEx</a>',
        // maxNativeZoom: 17,
        maxNativeZoom: 16,
        maxZoom: 20
      }),
      overlay_bdgex_relevo: L.tileLayer.wms('https://bdgex.eb.mil.br/mapcache?', {
        // layers: 'ieders_mi290_portao'
        layers: 'Multiescala_Relevo',
        format: 'image/png',
        transparent: true,
        tiled: true,
        // srs: 'EPSG:4326',
        crs: L.CRS.EPSG4326,
        // attribution: 'https://bdgex.eb.mil.br/',
        attribution: 'Camada de relevo por <a target="_blank" href="https://bdgex.eb.mil.br/">BDGEx</a>',
        // maxNativeZoom: 17,
        maxNativeZoom: 16,
        maxZoom: 20
      }),
      // baseLayers: {
      //   'OpenStreetMap': _VarsMap.tiles_osm,
      //   'OpenTopoMap': _VarsMap.tiles_openTopoMap,
      //   'Cartas Topográficas do Exército Brasileiro': _VarsMap.tiles_bdgex,
      //   // 'Bing': BingLayer
      //   // 'Bing': L.BingLayer
      //   // 'Bing': tiles_bing
      // },
      // overlays: {
      //   'Hidrografia - Exército Brasileiro': overlay_bdgex_hidrigrafia,
      //   'Relevo - Exército Brasileiro': overlay_bdgex_relevo,
      // }
    }

    const baseLayers = {
      'OpenStreetMap': _VarsMap.tiles_osm,
      'OpenTopoMap': _VarsMap.tiles_openTopoMap,
      'Cartas Topográficas do Exército Brasileiro': _VarsMap.tiles_bdgex,
      // 'Bing': BingLayer
      // 'Bing': L.BingLayer
      // 'Bing': tiles_bing
    };

    const overlays = {
      'Hidrografia - Exército Brasileiro': _VarsMap.overlay_bdgex_hidrigrafia,
      'Relevo - Exército Brasileiro': _VarsMap.overlay_bdgex_relevo,
    };

    const map = L.map('map', {
      center: [-14.9362, -51.8455],
      zoom: 4,
      //layers: 
      layers: [_VarsMap.tiles_osm]
    });

    const markers = L.markerClusterGroup(
      {
        maxClusterRadius: 10 // Default: 80
      }
    );

    // const layerControl = L.control.layers(baseLayers, overlays).addTo(map);
    const layerControl = L.control.layers(_VarsMap.baseLayers, _VarsMap.overlays).addTo(map);

    //const map = L.map('map').setView([-14.936266441326534, -51.845590165709055], 4);

    // const render_active = document.getElementById("render_active");


    const update_map = function () {

      map.eachLayer((layer) => {
        if (layer['_latlng'] != undefined)
          layer.remove();
      });

      // var markers = L.markerClusterGroup(
      //   {
      //     maxClusterRadius: 10 // Default: 80
      //   }
      // );
      markers.clearLayers();

      //console.log('update_map', WorkingInputFiles)

      const _baseurl_icons = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-'

      const LeafIcon = L.Icon.extend({
        options: {
          // iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
          iconUrl: _baseurl_icons + 'blue.png',
          shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          shadowSize: [41, 41]
        }
      });


      const blueIcon = new LeafIcon({ iconUrl: _baseurl_icons + 'blue.png' });
      const greenIcon = new LeafIcon({ iconUrl: _baseurl_icons + 'green.png' });
      const goldIcon = new LeafIcon({ iconUrl: _baseurl_icons + 'gold.png' });
      const orangeIcon = new LeafIcon({ iconUrl: _baseurl_icons + 'orange.png' });
      const redIcon = new LeafIcon({ iconUrl: _baseurl_icons + 'red.png' });
      const yellowIcon = new LeafIcon({ iconUrl: _baseurl_icons + 'yellow.png' });
      const violetIcon = new LeafIcon({ iconUrl: _baseurl_icons + 'violet.png' });
      const greyIcon = new LeafIcon({ iconUrl: _baseurl_icons + 'grey.png' });
      const blackIcon = new LeafIcon({ iconUrl: _baseurl_icons + 'black.png' });
      const list_icons = [
        blueIcon, greenIcon, goldIcon, orangeIcon, redIcon, yellowIcon, violetIcon, greyIcon, blackIcon
      ]

      const LeafIconFocus = L.Icon.extend({
        options: {
          // iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
          iconUrl: _baseurl_icons + 'blue.png',
          shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          shadowSize: [41, 41],
          className: "pin-focus"
        }
      });

      const blueIconFocus = new LeafIconFocus({ iconUrl: _baseurl_icons + 'blue.png' });
      const greenIconFocus = new LeafIconFocus({ iconUrl: _baseurl_icons + 'green.png' });
      const goldIconFocus = new LeafIconFocus({ iconUrl: _baseurl_icons + 'gold.png' });
      const orangeIconFocus = new LeafIconFocus({ iconUrl: _baseurl_icons + 'orange.png' });
      const redIconFocus = new LeafIconFocus({ iconUrl: _baseurl_icons + 'red.png' });
      const yellowIconFocus = new LeafIconFocus({ iconUrl: _baseurl_icons + 'yellow.png' });
      const violetIconFocus = new LeafIconFocus({ iconUrl: _baseurl_icons + 'violet.png' });
      const greyIconFocus = new LeafIconFocus({ iconUrl: _baseurl_icons + 'grey.png' });
      const blackIconFocus = new LeafIconFocus({ iconUrl: _baseurl_icons + 'black.png' });
      const list_iconsFocus = [
        blueIconFocus, greenIconFocus, goldIconFocus, orangeIconFocus, redIconFocus, yellowIconFocus, violetIconFocus, greyIconFocus, blackIconFocus
      ]

      let geoJsonLayer_cluster = []
      // for (const [key, value] of Object.entries(WorkingInputFiles)) {
      //   // console.log(`${key}: ${value}`);
      //   let selection = []
      //   SDMData.MainPreview.forEach(function (item) {
      //     if (item["__did"] == key) {
      //       selection.push(item)
      //     }
      //   })

      for (const selection of SDMData.MainPreview) {

        // console.log('selection', selection)

        // let icon = L.divIcon({
        //   className: 'did-' + key
        // })
        // var greenIcon = new L.Icon({
        //   iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
        //   shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
        //   iconSize: [25, 41],
        //   iconAnchor: [12, 41],
        //   popupAnchor: [1, -34],
        //   shadowSize: [41, 41]
        // });


        function createMarker(feature, latlng) {
          const modulo = feature['__did'] % list_icons.length
          // let selected_group = 
          // console.log('modulo', modulo, list_icons[modulo])
          // return L.marker(latlng, { icon: list_icons[modulo] });
          // return L.marker(latlng, { icon: greenIcon });

          if (_Etc.focus_did === feature['__did']) {
            return L.marker(latlng, { icon: list_iconsFocus[modulo] });
          } else {
            return L.marker(latlng, { icon: list_icons[modulo] });
          }
        }

        var teste = geoJsonLayer_cluster.push(L.geoJSON(selection, {
          onEachFeature: UI.onEachFeature,
          pointToLayer: createMarker,
          //icon: icon,
          //style: {className: 'did-' + key}
        }))
        //console.log('teste', teste)
        //console.log('teste', geoJsonLayer_cluster[teste])
        //console.log('teste', geoJsonLayer_cluster)
      }

      /*
      // L.geoJSON(geojsonFeature, {
      var geoJsonLayer = L.geoJSON(SDMData.MainPreview, {
        onEachFeature: onEachFeature,
        //style: myStyle,
        //pointToLayer: function (feature, latlng) {
        //  return L.circleMarker(latlng, geojsonMarkerOptions);
        //}
        //style: { color: "#0000ff" }
        // style: function (feature) {
        //   return color_pallete(feature['__did']);
        //   // return { color: feature.properties.color };
        // },
        // }).addTo(map);
      })
      //.addTo(map);
     

      markers.addLayer(geoJsonLayer);
       */


      markers.addLayers(geoJsonLayer_cluster);

      // console.log('markers', markers)
      // console.log('markers.getBounds()', markers.getBounds())

      // https://hungchienhsiang.medium.com/super-simple-way-to-change-leaflet-marker-color-7efd0996c797
      // markers._icon.classList.add("huechange");

      map.addLayer(markers);
      // console.log('markers', markers)
      if (SDMData.MainPreview.length > 0) {

        // try {
        //   map.fitBounds(markers.getBounds());
        // } catch (error) {
        //   // console.log(error)
        // }
        if (document.getElementById("v_map_autofocus").checked) {
          map.fitBounds(markers.getBounds());
        }
      }

      // console.log('markers', markers)
      // console.log('map', map)
      // for (const [key, value] of Object.entries(markers._map._layers)) {
      //   console.log('value', value)
      //   if (value.hasOwnProperty("features") && value["features"].hasOwnProperty("__did")) {
      //     value._icon.classList.add("did-" + value["features"]["__did"])
      //   }
      // }
      // console.log('todo render_active')
      // console.log(filter_active_simple.value)
    }

    document.addEventListener("DOMContentLoaded", UI.init_ui)

    //document.getElementById("ui_text_preview").addEventListener('change', update_ui)
    document.getElementById("ui_text_nopos_preview").addEventListener('change', UI.update_ui)
    document.getElementById("ui_map_preview").addEventListener('change', UI.update_ui)
    // document.getElementById("ui_filter_extras").addEventListener('change', update_ui)
    document.getElementById("filter_active_latlon").addEventListener('change', UI.update_ui_refpos)
    document.getElementById("filter_active_latlon_dist").addEventListener('change', UI.update_ui_refpos)
    // https://stackoverflow.com/questions/41256026/clear-marker-layers-leaflet

    UIb.filter_active_simple.addEventListener('keyup', function (ev) {
      // console.log(ev)
      UI.update_filter_delayed()

      // if (document.getElementById('ui_map_preview').checked) {
      //   // console.log('todo update map now (TODO otimize only one render)')
      //   update_map()
      // }
      // update_map()
      // console.log(filter_active_simple.value)
    })

    filter_active_latlon.addEventListener('keyup', function (ev) {
      UI.update_ui_refpos()
      UI.update_filter_delayed()
      // update_map()
      // if (document.getElementById('ui_map_preview').checked) {
      //   update_map()
      // }
    })
    filter_active_latlon_dist.addEventListener('keyup', function (ev) {
      UI.update_ui_refpos()
      UI.update_filter_delayed()
      // update_map()
      // if (document.getElementById('ui_map_preview_realtime').checked) {
      //   //   update_map()
      // }
    })

    // render_active.addEventListener('click', function (ev) {
    //   // console.log(ev)
    //   update_map()

    // })

  </script>
  <!-- <script src="main.js"></script> -->
</body>

</html>